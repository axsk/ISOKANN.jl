var documenterSearchIndex = {"docs":
[{"location":"isomu/#IsoMu","page":"IsoMu","title":"IsoMu","text":"","category":"section"},{"location":"isomu/","page":"IsoMu","title":"IsoMu","text":"Analysing trajectory data from mu opiod receptor with ISOKANN and reaction path subsampling.","category":"page"},{"location":"isomu/","page":"IsoMu","title":"IsoMu","text":"contact: a sikorski, s chewle","category":"page"},{"location":"isomu/#Loading-the-julia-project","page":"IsoMu","title":"Loading the julia project","text":"","category":"section"},{"location":"isomu/","page":"IsoMu","title":"IsoMu","text":"run julia (install via: google juliaup)\nactivate the project julia> ]activate .\nupdate ISOKANN to their github master branches","category":"page"},{"location":"isomu/","page":"IsoMu","title":"IsoMu","text":"julia> ]add https://github.com/axsk/ISOKANN.jl","category":"page"},{"location":"isomu/","page":"IsoMu","title":"IsoMu","text":"load the module via julia> using ISOKANN, ISOKANN.IsoMu","category":"page"},{"location":"isomu/#Running-the-clustering","page":"IsoMu","title":"Running the clustering","text":"","category":"section"},{"location":"isomu/","page":"IsoMu","title":"IsoMu","text":"# create a DataLink to the trajectory's directory\nlink = DataLink(\"path/to/traj\")\n\n# create the ISOKANN environment\nmu = isokann(link)\n\n# train the network\ntrain!(mu)\n\n# save the reactive path\nsave_reactive_path(mu, sigma=0.1, out=\"out/path.pbd\", method=IsoMu.MaxPath())\n","category":"page"},{"location":"isomu/#Starting-on-SLURM-with-gpu","page":"IsoMu","title":"Starting on SLURM with gpu","text":"","category":"section"},{"location":"isomu/","page":"IsoMu","title":"IsoMu","text":"srun –gres=gpu –partition gpu –constraint \"A40-RTX-48GB\" –pty bash","category":"page"},{"location":"isomu/","page":"IsoMu","title":"IsoMu","text":"then ISOKANN.gpu!(mu::IsoRun)","category":"page"},{"location":"isomu/#A-more-advanced-example","page":"IsoMu","title":"A more advanced example","text":"","category":"section"},{"location":"isomu/","page":"IsoMu","title":"IsoMu","text":"using IsoMu, Flux\n\n# read the trajectory from the 10th frame, every 10 frames with distance cutoff 10 and reverse the trajectory\ndata = DataLink(\"data/8EF5_500ns_pka_7.4_no_capping_310.10C/\", startpos=10, stride=10, radius=10, reverse=true)\n\n# specify the network and training parameters\nmu = isokann(data, networkargs=(;layers=4, activation=Flux.leakyrelu), learnrate = 1e-3, regularization=1e-4, minibatch=256,)\n\ngpu!(mu)  # transfer model to gpu\ntrain!(mu, 10000)  # 10000 iterations\nadjust!(mu, 1e-4, lambda=1e-3) # set learnrate to 1e-4 and decay to 1e-3\ntrain!(mu, 10000)  # 10000 iterations","category":"page"},{"location":"introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"This package provides the core ISOKANN algorithm as well as some wrappers and convenience routines to work with different kind of simulations and data.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The core ISOKANN algorithm is accessed by the Iso type, which holds the neural network, optimizer, ISOKANN parameters and training data.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"You can construct it by passing a tuple of (xs, ys) of arrays as input data. Here xs is a matrix where the columns are starting points of trajectories and ys is a 3 dimensional array where ys[d,k,n] is the d-th coordinate of the k-th Koopman-replica of the n-th trajectory.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"To start training the neural network simply call the run! function passing the Iso object and the number of ISOKANN iterations. The resulting \\chi values can be obtained via the chis method","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"iso=Iso((rand(3,100), rand(3,10,100)))\nrun!(iso)\nchis(iso)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"For more advanced use, such as with the adaptive sampling algorithms we pass a SimulationData object instead of the data tuple to the Iso constructor.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The SimulationData itself is composed of a Simulation, its simulated trajectory data as well as the features fed into the neural network for training. We supply some basic simulations which can generate the data, e.g. Doublewell, MuellerBrown, Diffusion, MollySimulation and OpenMMSimulation. Of course you can write your own Simulation which in its most basic form needs to supply only the propagate method.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"sim = Doublewell()\ndata = isodata(sim, 100, 20)\niso = Iso(data)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"We also provide different type of wrappers to load simulations [vgv] or generate data from trajectories [IsoMu].","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"For an advanced example take a look at the scripts/vgvadapt.jl file.","category":"page"},{"location":"introduction/#Components","page":"Introduction","title":"Components","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The OpenMMSimulation is a good example for an Simulation object. It parametrises a system by specifying a molecular simulation by reading the molecular structure from a .pdb file but also the system temperature, the simulation lag time and other simulation parameters.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The SimulationData in turn links such a simulation Simulation to actual simulation data which is used by ISOKANN for training. Through the specification of a featurizer the neural network does not need to digest the simulation coordinates but can use optimized features which for example guarantee invariance under rigid transformations. By default the featurizer is inhereted from the default featurizer of the Simulation. For the OpenMMSimulation we have pre-implemented pairwise distances between all atoms, locally close atoms and/or the c-Alpha atoms (c.f. the OpenMMSimulation docstring).","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The Iso object then brings together the SimulationData with a neural network model and an optimizer. Its main use is together with the training routine run!() which computes the ISOKANN iteration via isotarget and updates the networks weights with train_batch. The logger field allows to ammend other operations such as the default autoplot() which displays the progress during training. The default model is the pairnet which constructs a fully connected network of a given number of layers of descreasing width and the default optimizer is Adam with weight decay.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Adaptive sampling is facilitated either by the runadaptive! method, or the individual adddata!, resample_kde!, addextrapolates! used in a custom training routine.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The learned chi values can be accessed via chis(::Iso) and the reaction rates via exit_rates(::Iso)","category":"page"},{"location":"introduction/#Contents-of-the-source-files","page":"Introduction","title":"Contents of the source files","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Core:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"simulation.jl: handling of SimulationData which mainly dispatches to other lower-level functions\ndata.jl: low level functions for accessing and manipulating the data tuple\niso2.jl: main training routine\nisotarget.jl:  different ISOKANN iteration targets  for 1D and higher dimensional chi functions\nmodels.jl: convencience functions for the contruction/manipulation of model and optimiser","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Simulators:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"simulators/langevin.jl: A simulator for the Langevin equation\nsimulators/openmm.jl: Wrapper around OpenMM for molecular dynamics simulations","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Utility:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"molutils.jl: different utilities to work with molecules and molecular data, such as alignment, dihedrals etc.\npairdists.jl: different methods to compute pairwise distance features\nplots.jl: plotting functionality\nsubsample.jl: stratified or KDE based uniform subsampling along a given reaction coordinate","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Experimental:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"extrapolate.jl: generation of new sampling points by extrapolating on the neural network (dreaming)\nbonito.jl and makie.jl: live visualizations via Makie.jl/WebGL and the dashboard using the Bonito.jl webserver\nreactionpath.jl: reaction paths by integration on the neural network\nreactionpath2.jl: reactive path extraction from sampled data by solving shortest paths problems","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Install Julia (>=v1.10) using https://github.com/JuliaLang/juliaup","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"curl -fsSL https://install.julialang.org | sh","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"After restarting your shell you should be able to start the Julia REPL via the command julia.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"In the REPL you can add ISOKANN.jl to your project by entering the package mode (type ]) and typing","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"pkg> add ISOKANN\npkg> test ISOKANN","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Note that this can take a while on the first run as Julia downloads and precompiles all dependencies.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"We plan on installing OpenMM automatically with ISOKANN. Right now, if you want to use openmm with ISOKANN you will need to make it available to PyCall.jl. This should work automatically, when Julia is using its own Conda.jl Conda environment: ","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"starting julia with the environment variable shell> PYTHON=\"\" julia \nrebuild PyCall pkg> build PyCall.)","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"See also the PyCall docs.","category":"page"},{"location":"installation/#Development","page":"Installation","title":"Development","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"If you want to make changes to ISOKANN you should clone it into a directory","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"git clone git@github.com:axsk/ISOKANN.jl.git","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Then start Julia in that directory, activate it with ]activate ., instantiate the dependencies with ]instantiate.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"You should then be able to run the tests with ]test or start using ISOKANN.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"We strongly recommend the Revise.jl package (using Revise) before ISOKANN, so that your changes will automatically load in your current session.","category":"page"},{"location":"#ISOKANN.jl","page":"ISOKANN.jl","title":"ISOKANN.jl","text":"","category":"section"},{"location":"","page":"ISOKANN.jl","title":"ISOKANN.jl","text":"Documentation for ISOKANN.jl","category":"page"},{"location":"","page":"ISOKANN.jl","title":"ISOKANN.jl","text":"CurrentModule = ISOKANN","category":"page"},{"location":"#Main-entry-points","page":"ISOKANN.jl","title":"Main entry points","text":"","category":"section"},{"location":"","page":"ISOKANN.jl","title":"ISOKANN.jl","text":"SimulationData\nOpenMMSimulation\npropagate\nIso\nrun!","category":"page"},{"location":"#ISOKANN.SimulationData","page":"ISOKANN.jl","title":"ISOKANN.SimulationData","text":"struct SimulationData{S,D,C,F}\n\nA struct combining a simulation with the simulated coordinates and corresponding ISOKANN trainingsdata\n\nFields\n\nsim::S: The simulation object.\ndata::D: The ISOKANN trainings data.\ncoords::C: The orginal coordinates of the simulations.\nfeaturizer::F: A function mapping coordinates to ISOKANN features.\n\n\n\n\n\n","category":"type"},{"location":"#ISOKANN.OpenMM.OpenMMSimulation","page":"ISOKANN.jl","title":"ISOKANN.OpenMM.OpenMMSimulation","text":"OpenMMSimulation(; pdb, steps, ...)\nOpenMMSimulation(; py, steps)\n\nConstructs an OpenMM simulation object. Either use  OpenMMSimulation(;py, steps) where pyis the location of a .py python script creating a OpenMM simulation object or supply a .pdb file viapdb` and the following parameters (see also defaultsystem):\n\nArguments\n\npdb::String: Path to the PDB file.\nligand::String: Path to ligand file.\nforcefields::Vector{String}: List of force field XML files.\ntemp::Float64: Temperature in Kelvin.\nfriction::Float64: Friction coefficient in 1/picosecond.\nstep::Float64: Integration step size in picoseconds.\nsteps::Int: Number of simulation steps.\nfeatures: Which features to use for learning the chi function.             -  A vector of Int denotes the indices of all atoms to compute the pairwise distances from.             -  A vector of CartesianIndex{2} computes the specific distances between the atom pairs.             -  A number denotes the radius below which all pairs of atoms will be used (computed only on the starting configuration)             -  If nothing all pairwise distances are used.\nminimize::Bool: Whether to perform energy minimization on first state.\nnthreads: The number of threads to use for parallelization of multiple simulations.\nmmthreads: The number of threads to use for each OpenMM simulation. Set to \"gpu\" to use the GPU platform.\n\nReturns\n\nOpenMMSimulation: An OpenMMSimulation object.\n\n\n\n\n\n","category":"type"},{"location":"#ISOKANN.propagate","page":"ISOKANN.jl","title":"ISOKANN.propagate","text":"propagate(s::OpenMMSimulation, x0::AbstractMatrix{T}, ny; nthreads=Threads.nthreads(), mmthreads=1) where {T}\n\nPropagates ny replicas of the OpenMMSimulation s from the inintial states x0.\n\nArguments\n\ns: An instance of the OpenMMSimulation type.\nx0: Matrix containing the initial states as columns\nny: The number of replicas to create.\n\nOptional Arguments\n\nnthreads: The number of threads to use for parallelization of multiple simulations.\nmmthreads: The number of threads to use for each OpenMM simulation. Set to \"gpu\" to use the GPU platform.\n\nNote: For CPU we observed better performance with nthreads = num cpus, mmthreads = 1 then the other way around. With GPU nthreads > 1 should be supported, but on our machine lead to slower performance then nthreads=1.\n\n\n\n\n\n","category":"function"},{"location":"#ISOKANN.Iso","page":"ISOKANN.jl","title":"ISOKANN.Iso","text":"Iso(data; opt=NesterovRegularized(), model=defaultmodel(data), gpu=false, kwargs...)\n\n\n\n\n\nIso(sim::IsoSimulation; nx=100, nk=10, nd=1, kwargs...)\n\nConvenience constructor which generates the SimulationData from the simulation sim and constructs the Iso object. See also Iso(data; kwargs...)\n\nArguments\n\nsim::IsoSimulation: The IsoSimulation object.\nnx::Int: The number of starting points.\nnk::Int: The number of koopman samples.\nnout::Int: Dimension of the χ function.\n\n\n\n\n\n","category":"type"},{"location":"#ISOKANN.run!","page":"ISOKANN.jl","title":"ISOKANN.run!","text":"run!(iso::Iso, n=1, epochs=1)\n\nRun the training process for the Iso model.\n\nArguments\n\niso::Iso: The Iso model to train.\nn::Int: The number of (outer) Koopman iterations.\nepochs::Int: The number of (inner) epochs to train the model for each Koopman evaluation.\n\n\n\n\n\n","category":"function"},{"location":"#Public-API","page":"ISOKANN.jl","title":"Public API","text":"","category":"section"},{"location":"","page":"ISOKANN.jl","title":"ISOKANN.jl","text":"Modules = [ISOKANN, ISOKANN.OpenMM]\nPrivate = false","category":"page"},{"location":"#ISOKANN.Iso-Tuple{Any}","page":"ISOKANN.jl","title":"ISOKANN.Iso","text":"Iso(data; opt=NesterovRegularized(), model=defaultmodel(data), gpu=false, kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.Iso-Tuple{ISOKANN.IsoSimulation}","page":"ISOKANN.jl","title":"ISOKANN.Iso","text":"Iso(sim::IsoSimulation; nx=100, nk=10, nd=1, kwargs...)\n\nConvenience constructor which generates the SimulationData from the simulation sim and constructs the Iso object. See also Iso(data; kwargs...)\n\nArguments\n\nsim::IsoSimulation: The IsoSimulation object.\nnx::Int: The number of starting points.\nnk::Int: The number of koopman samples.\nnout::Int: Dimension of the χ function.\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.SimulationData-Tuple{ISOKANN.IsoSimulation, Int64, Int64}","page":"ISOKANN.jl","title":"ISOKANN.SimulationData","text":"SimulationData(sim::IsoSimulation, nx::Int, nk::Int; ...)\nSimulationData(sim::IsoSimulation, xs::AbstractMatrix, nk::Int; ...)\nSimulationData(sim::IsoSimulation, (xs,ys); ...)\n\nGenerates SimulationData from a simulation with either\n\nnx initial points and nk Koopman samples\nxs as initial points and nk Koopman sample\nxs as inintial points and ys as Koopman samples\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.AdamRegularized","page":"ISOKANN.jl","title":"ISOKANN.AdamRegularized","text":"Adam with L2 regularization. Note that this is different from AdamW (Adam+WeightDecay) (c.f. Decay vs L2 Reg.) \n\n\n\n\n\n","category":"function"},{"location":"#ISOKANN.data_from_trajectory-Tuple{AbstractMatrix}","page":"ISOKANN.jl","title":"ISOKANN.data_from_trajectory","text":"data_from_trajectory(xs::AbstractMatrix; reverse=false) :: DataTuple\n\nGenerate the lag-1 data from the trajectory xs. If reverse is true, also take the time-reversed lag-1 data.\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.laggedtrajectory-Tuple{SimulationData, Any}","page":"ISOKANN.jl","title":"ISOKANN.laggedtrajectory","text":"laggedtrajectory(data::SimulationData, n) = laggedtrajectory(data.sim, n, x0=data.coords[1][:, end])\n\nSimulate a trajectory comprising of n simulations from the last point in data\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.load_trajectory-Tuple{Any}","page":"ISOKANN.jl","title":"ISOKANN.load_trajectory","text":"load_trajectory(filename; top=nothing, kwargs...)\n\nwrapper around Python's mdtraj.load(). Returns a (3 * natom, nframes) shaped array.\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.localpdistinds-Tuple{AbstractMatrix, Any}","page":"ISOKANN.jl","title":"ISOKANN.localpdistinds","text":"localpdistinds(coords::AbstractMatrix, radius)\n\nGiven coords of shape ( 3n x frames ) return the pairs of indices whose minimal distance along all frames is at least once lower then radius\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.mergedata-Tuple{SimulationData, SimulationData}","page":"ISOKANN.jl","title":"ISOKANN.mergedata","text":"mergedata(d1::SimulationData, d2::SimulationData)\n\nMerge the data and features of d1 and d2, keeping the simulation and features of d1. Note that there is no check if simulation features agree.\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.pairnet-Tuple{}","page":"ISOKANN.jl","title":"ISOKANN.pairnet","text":"Fully connected neural network with layers layers from n to nout dimensions. features allows to pass a featurizer as preprocessor, activation determines the activation function for each but the last layer lastactivation can be used to modify the last layers activation function \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.pdists-Union{Tuple{T}, Tuple{AbstractMatrix, Array{Tuple{T, T}, 1}}} where T","page":"ISOKANN.jl","title":"ISOKANN.pdists","text":"pdists(coords::AbstractArray, inds::Vector{<:Tuple})\n\nCompute the pairwise distances between the particles specified by the tuples inds over all frames in traj. Assumes a column contains all 3n coordinates.\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.reactionpath_minimum","page":"ISOKANN.jl","title":"ISOKANN.reactionpath_minimum","text":"reactionpath_minimum(iso::Iso, x0; steps=100)\n\nCompute the reaction path by integrating ∇χ with orthogonal energy minimization.\n\nArguments\n\niso::Iso: The isomer for which the reaction path minimum is to be computed.\nx0: The starting point for the reaction path computation.\nsteps=100: The number of steps to take along the reaction path.\n\n\n\n\n\n","category":"function"},{"location":"#ISOKANN.reactionpath_ode-Tuple{Any, Any}","page":"ISOKANN.jl","title":"ISOKANN.reactionpath_ode","text":"reactionpath_ode(iso, x0; steps=101, extrapolate=0, orth=0.01, solver=OrdinaryDiffEq.Tsit5(), dt=1e-3, kwargs...)\n\nCompute the reaction path by integrating ∇χ as well as orth * F orthogonal to ∇χ where F is the original force field.\n\nArguments\n\niso::Iso: The isomer for which the reaction path minimum is to be computed.\nx0: The starting point for the reaction path computation.\nsteps=100: The number of steps to take along the reaction path.\nminimize=false: Whether to minimize the orthogonal to ∇χ before integration.\nextrapolate=0: How fast to extrapolate beyond χ 0 and 1.\north=0.01: The weight of the orthogonal force field.\nsolver=OrdinaryDiffEq.Tsit5(): The solver to use for the ODE integration.\ndt=1e-3: The initial time step for the ODE integration.\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.reactive_path-Tuple{AbstractVector, AbstractMatrix}","page":"ISOKANN.jl","title":"ISOKANN.reactive_path","text":"reactive_path(xi::AbstractVector, coords::AbstractMatrix; sigma, maxjump=1, method=QuantilePath(0.05), normalize=false, sortincreasing=true)\n\nFind the maximum likelihood path (under the model of brownion motion with noise sigma) through coords with times xi. Supports either CPU or GPU arrays.\n\nArguments\n\ncoords:  (ndim x npoints) matrix of coordinates.\nxi: time coordinate of the npoints points\nsigma: spatial noise strength of the model.\nmaxjump: upper bound to the jump in time xi along the path.\nmethod: either FromToPath,  QuantilePath, FullPath or MaxPath, specifying the end points of the path\nnormalize: whether to normalize all coords first\nsortincreasing: return the path from lower to higher xi values\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.restricted_localpdistinds-Tuple{Any, Any, Any}","page":"ISOKANN.jl","title":"ISOKANN.restricted_localpdistinds","text":"restricted_localpdistinds(coords, radius, atoms)\n\nLike localdists, but consider only the atoms with index in atoms\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.run!-2","page":"ISOKANN.jl","title":"ISOKANN.run!","text":"run!(iso::Iso, n=1, epochs=1)\n\nRun the training process for the Iso model.\n\nArguments\n\niso::Iso: The Iso model to train.\nn::Int: The number of (outer) Koopman iterations.\nepochs::Int: The number of (inner) epochs to train the model for each Koopman evaluation.\n\n\n\n\n\n","category":"function"},{"location":"#ISOKANN.runadaptive!-Tuple{Any}","page":"ISOKANN.jl","title":"ISOKANN.runadaptive!","text":"runadaptive!(iso; generations=1, nx=10, iter=100, cutoff=Inf)\n\nTrain iso with adaptive sampling. Sample nx new data points followed by iter isokann iterations and repeat this generations times. cutoff specifies the maximal data size, after which new data overwrites the oldest data.\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.save_reactive_path","page":"ISOKANN.jl","title":"ISOKANN.save_reactive_path","text":"save_reactive_path(iso::Iso,\n    coords::AbstractMatrix=getcoords(iso.data) |> cpu;\n    sigma=1,\n    maxjump=1,\n    out=\"out/reactive_path.pdb\",\n    source=pdbfile(iso.data),\n    kwargs...)\n\nExtract and save the reactive path of a given iso.\n\nComputes the maximum likelihood path with parameter sigma along the given data points, aligns it and saves it to the out path.\n\nSee also reactive_path.\n\nArguments\n\niso::Iso: The Iso for which the reactive path is computed.\nout=\"out/reactive_path.pdb\": The output file path for saving the reactive path.\nsource: The source .pdb file providing the topology\nkwargs...: additional parameters passed to reactive_path.\n\nReturns\n\nids: The IDs of the reactive path.\n\n\n\n\n\n","category":"function"},{"location":"#ISOKANN.save_trajectory-Tuple{Any, AbstractMatrix}","page":"ISOKANN.jl","title":"ISOKANN.save_trajectory","text":"save_trajectory(filename, coords::AbstractMatrix; top::String)\n\nsave the trajectory given in coords to filename with the topology provided by the file top using mdtraj.\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.trajectorydata_bursts-Tuple{ISOKANN.IsoSimulation, Any, Any}","page":"ISOKANN.jl","title":"ISOKANN.trajectorydata_bursts","text":"trajectorydata_bursts(sim::IsoSimulation, steps, nk; kwargs...)\n\nSimulate a single long trajectory of steps times the lagtime and start nk burst trajectories at each step for the Koopman samples.\n\nx0–-x––x–-     / |  / |     y y  y y\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.trajectorydata_linear-Tuple{ISOKANN.IsoSimulation, Any}","page":"ISOKANN.jl","title":"ISOKANN.trajectorydata_linear","text":"trajectorydata_linear(sim::IsoSimulation, steps; reverse=false, kwargs...)\n\nSimulate a single long trajectory of steps times the lagtime and use this \"chain\" to generate the corresponding ISOKANN data. If reverse is true, also add the time-reversed transitions\n\nx (<)–> x (<)–> x\n\n\n\n\n\n","category":"method"},{"location":"#Internal-API","page":"ISOKANN.jl","title":"Internal API","text":"","category":"section"},{"location":"","page":"ISOKANN.jl","title":"ISOKANN.jl","text":"Modules = [ISOKANN, ISOKANN.OpenMM]\nPublic = false","category":"page"},{"location":"#ISOKANN.DataTuple","page":"ISOKANN.jl","title":"ISOKANN.DataTuple","text":"DataTuple = Tuple{Matrix{T},Array{T,3}} where {T<:Number}\n\nWe represent data as a tuple of xs and ys.\n\nxs is a matrix of size (d, n) where d is the dimension of the system and n the number of samples. ys is a tensor of size (d, k, n) where k is the number of koopman samples.\n\n\n\n\n\n","category":"type"},{"location":"#ISOKANN.IsoSimulation","page":"ISOKANN.jl","title":"ISOKANN.IsoSimulation","text":"abstract type IsoSimulation\n\nAbstract type representing an IsoSimulation. Should implement the methods getcoords, propagate, dim\n\n\n\n\n\n","category":"type"},{"location":"#ISOKANN.Stabilize2","page":"ISOKANN.jl","title":"ISOKANN.Stabilize2","text":"TransformStabilize(transform, last=nothing)\n\nWraps another transform and permutes its target to match the previous target\n\nCurrently we also have the stablilization (wrt to the model though) inside each Transform. TODO: Decide which to keep\n\n\n\n\n\n","category":"type"},{"location":"#ISOKANN.TransformISA","page":"ISOKANN.jl","title":"ISOKANN.TransformISA","text":"TransformISA(permute)\n\nCompute the target via the inner simplex algorithm (without feasiblization routine). permute specifies whether to apply the stabilizing permutation \n\n\n\n\n\n","category":"type"},{"location":"#ISOKANN.TransformPseudoInv","page":"ISOKANN.jl","title":"ISOKANN.TransformPseudoInv","text":"TransformPseudoInv(normalize, direct, eigenvecs, permute)\n\nCompute the target by approximately inverting the action of K with the Moore-Penrose pseudoinverse.\n\nIf direct==true solve chi * pinv(K(chi)), otherwise inv(K(chi) * pinv(chi))). eigenvecs specifies whether to use the eigenvectors of the schur matrix. normalize specifies whether to renormalize the resulting target vectors. permute specifies whether to permute the target for stability.\n\n\n\n\n\n","category":"type"},{"location":"#ISOKANN.TransformShiftscale","page":"ISOKANN.jl","title":"ISOKANN.TransformShiftscale","text":"TransformShiftscale()\n\nClassical 1D shift-scale (ISOKANN 1) \n\n\n\n\n\n","category":"type"},{"location":"#ISOKANN._pickclosestloop-Tuple{AbstractVector, AbstractVector}","page":"ISOKANN.jl","title":"ISOKANN._pickclosestloop","text":"scales with n=length(hs) \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.adddata-NTuple{4, Any}","page":"ISOKANN.jl","title":"ISOKANN.adddata","text":"adddata(data::D, model, sim, ny, lastn=1_000_000)::D\n\nGenerate new data for ISOKANN by adaptive subsampling using the chi-stratified/-uniform method.\n\nAdaptively subsample ny points from data uniformly along their model values.\npropagate according to the simulation model.\nreturn the newly obtained data concatenated to the input data\n\nThe subsamples are taken only from the lastn last datapoints in data.\n\nExamples\n\njulia> (xs, ys) = adddata((xs,ys), chi, mollysim)\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.adddata-Tuple{SimulationData, Any, Any}","page":"ISOKANN.jl","title":"ISOKANN.adddata","text":"adddata(d::SimulationData, model, n)\n\nχ-stratified subsampling. Select n samples amongst the provided ys/koopman points of d such that their χ-value according to model is approximately uniformly distributed and propagate them. Returns a new SimulationData which has the new data appended.\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.addextrapolates!-Tuple{Any, Any}","page":"ISOKANN.jl","title":"ISOKANN.addextrapolates!","text":"addextrapolates!(iso, n, stepsize=0.01, steps=10)\n\nSample new data starting points obtained by extrapolating the chi function beyond the current extrema and attach it to the iso objects data.\n\nSamples n points at the lower and upper end each, resulting in 2n new points. stepis the magnitude of chi-value-change per step andsteps`` is the number of steps to take. E.g. 10 steps of stepsize 0.01 result in a change in chi of about 0.1.\n\nThe obtained data is filtered such that unstable simulations should be removed, which may result in less then 2n points being added.\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.bootstrap-Tuple{ISOKANN.IsoSimulation, Any, Any}","page":"ISOKANN.jl","title":"ISOKANN.bootstrap","text":"bootstrap(sim, nx, ny) :: DataTuple\n\ncompute initial data by propagating the molecules initial state to obtain the xs and propagating them further for the ys \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.centercoords-Tuple{Any}","page":"ISOKANN.jl","title":"ISOKANN.centercoords","text":"centercoords any given states by shifting their individual 3d mean to the origin\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.chi_exit_rate-Tuple{Any, Any, Any}","page":"ISOKANN.jl","title":"ISOKANN.chi_exit_rate","text":"compute the chi exit rate as per Ernst, Weber (2017), chap. 3.3 \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.energyminimization_chilevel-Tuple{Any, Any}","page":"ISOKANN.jl","title":"ISOKANN.energyminimization_chilevel","text":"energyminimization_chilevel(iso, x0; f_tol=1e-3, alphaguess=1e-5, iterations=20, show_trace=false, skipwater=false, algorithm=Optim.GradientDescent, xtol=nothing)\n\nLocal energy minimization on the current levelset of the chi function\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.exportdata","page":"ISOKANN.jl","title":"ISOKANN.exportdata","text":"exportdata(data::AbstractArray, model, sys, path=\"out/data.pdb\")\n\nExport data to a PDB file.\n\nThis function takes an AbstractArray data, sorts it according to the model evaluation, removes duplicates, transforms it to standard form and saves it as a PDB file  to path.\n\n\n\n\n\n","category":"function"},{"location":"#ISOKANN.extrapolate","page":"ISOKANN.jl","title":"ISOKANN.extrapolate","text":"extrapolate(iso, n, stepsize=0.1, steps=1, minimize=true)\n\nTake the n most extreme points of the chi-function of the iso object and extrapolate them by stepsize for steps steps beyond their extrema, resulting in 2n new points. If minimize is true, the new points are energy minimized.\n\n\n\n\n\n","category":"function"},{"location":"#ISOKANN.fixperm-Tuple{Any, Any}","page":"ISOKANN.jl","title":"ISOKANN.fixperm","text":"fixperm(new, old)\n\nPermutes the rows of new such as to minimize L1 distance to old.\n\nArguments\n\nnew: The data to match to the reference data.\nold: The reference data.\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.flatpairdists","page":"ISOKANN.jl","title":"ISOKANN.flatpairdists","text":"flatpairdists(x)\n\nAssumes each col of x to be a flattened representation of multiple 3d coords. Returns the flattened pairwise distances as columns.\n\n\n\n\n\n","category":"function"},{"location":"#ISOKANN.flattenfirst-Tuple{Any}","page":"ISOKANN.jl","title":"ISOKANN.flattenfirst","text":"collapse the first and second dimension of the array A into the first dimension \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.growmodel-Tuple{Any, Any}","page":"ISOKANN.jl","title":"ISOKANN.growmodel","text":"Given a model and return a copy with its last layer replaced with given output dimension n \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.inputdim-Tuple{Flux.Chain}","page":"ISOKANN.jl","title":"ISOKANN.inputdim","text":"obtain the input dimension of a Flux model \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.kabsch-Tuple{AbstractMatrix, AbstractMatrix}","page":"ISOKANN.jl","title":"ISOKANN.kabsch","text":"compute R such that R*p is closest to q\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.koopman-Tuple{Any, Any}","page":"ISOKANN.jl","title":"ISOKANN.koopman","text":"evluation of koopman by shiftscale(mean(model(data))) on the data \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.load-Tuple{String}","page":"ISOKANN.jl","title":"ISOKANN.load","text":"load(path::String, iso::Iso)\n\nLoad the Iso object from a JLD2 file Note that it will be loaded to the CPU, even if it was saved on the GPU. An OpenMMSimulation will be reconstructed anew from the saved pdb file.\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.model_with_opt","page":"ISOKANN.jl","title":"ISOKANN.model_with_opt","text":"convenience wrapper returning the provided model with the default AdamW optimiser \n\n\n\n\n\n","category":"function"},{"location":"#ISOKANN.outputdim-Tuple{Flux.Chain}","page":"ISOKANN.jl","title":"ISOKANN.outputdim","text":"Obtain the output dimension of a Flux model \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.pairdistfeatures-Tuple{AbstractVector}","page":"ISOKANN.jl","title":"ISOKANN.pairdistfeatures","text":"pairdistfeatures(inds::AbstractVector)\n\nReturns a featurizer function which computes the pairwise distances between the particles specified by inds\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.pickclosest_sort-Tuple{AbstractVector, AbstractVector}","page":"ISOKANN.jl","title":"ISOKANN.pickclosest_sort","text":"pickclosest(haystack, needles)\n\nReturn the indices into haystack which lie closest to needles without duplicates by removing haystack candidates after a match. Note that this is not invariant under pertubations of needles\n\nscales with n log(n) m where n=length(haystack), m=length(needles) \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.plotatoms!","page":"ISOKANN.jl","title":"ISOKANN.plotatoms!","text":"scatter plot of all first \"O\" atoms of the starting points xs as well as the \"O\" atoms from the koopman samples to the first point from ys\n\n\n\n\n\n","category":"function"},{"location":"#ISOKANN.plotlossdata","page":"ISOKANN.jl","title":"ISOKANN.plotlossdata","text":"combined plot of loss graph and current atoms \n\n\n\n\n\n","category":"function"},{"location":"#ISOKANN.reactionforce","page":"ISOKANN.jl","title":"ISOKANN.reactionforce","text":"reactionforce(iso, sim, x, direction, orth=1)\n\nCompute the vector f with colinear component to dchi/dx such that dchi/dx * f = 1 and orth*forcefield in the orthogonal space\n\n\n\n\n\n","category":"function"},{"location":"#ISOKANN.resample_kde-Tuple{Any, Any, Any}","page":"ISOKANN.jl","title":"ISOKANN.resample_kde","text":"resample_kde(xs, ys, n; kwargs...)\n\nReturn n indices of ys such that the corresponding points \"fill the gaps\" in the KDE of xs. For possible kwargs see kde_needles.\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.save-Tuple{String, Iso}","page":"ISOKANN.jl","title":"ISOKANN.save","text":"save(path::String, iso::Iso)\n\nSave the complete Iso object to a JLD2 file \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.savecoords","page":"ISOKANN.jl","title":"ISOKANN.savecoords","text":"savecoords(path::String, iso::Iso, inds=1:numobs(iso.data))\n\nSave the coordinates of the specified observation indices from the data of of iso to the file path.\n\nsavecoords(path::String, iso::Iso, coords::AbstractArray)\n\nSave the coordinates of the specified matrix of coordinates to a file, using the molecule in iso as a template.\n\n\n\n\n\n","category":"function"},{"location":"#ISOKANN.saveextrema-Tuple{String, Iso}","page":"ISOKANN.jl","title":"ISOKANN.saveextrema","text":"saveextrema(path::String, iso::Iso)\n\nSave the two extermal configurations (metastabilities) to the file path.\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.scatter_chifix-Tuple{Any, Any}","page":"ISOKANN.jl","title":"ISOKANN.scatter_chifix","text":"fixed point plot, i.e. x vs model(x) \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.selectrows-Tuple{Any, Any}","page":"ISOKANN.jl","title":"ISOKANN.selectrows","text":"given an array of arbitrary shape, select the rows inds in the first dimension \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.shiftscale-Tuple{Any}","page":"ISOKANN.jl","title":"ISOKANN.shiftscale","text":"empirical shift-scale operation \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.simulationtime-Tuple{SimulationData}","page":"ISOKANN.jl","title":"ISOKANN.simulationtime","text":"simulationtime(iso::Iso)\n\nprint and return the total simulation time contained in the data of iso in nanoseconds.\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.sqpairdist-Tuple{AbstractArray{<:Any, 3}}","page":"ISOKANN.jl","title":"ISOKANN.sqpairdist","text":"sqpairdist(x::AbstractArray)\n\nCompute the squared pairwise distances between the columns of x. If x has 3 dimensions, the computation is batched along the 3rd dimension.\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.subsample-Tuple{Any, AbstractMatrix, Any}","page":"ISOKANN.jl","title":"ISOKANN.subsample","text":"subsample(model, data::Array, n) :: Matrix\nsubsample(model, data::Tuple, n) :: Tuple\n\nSubsample n points of data uniformly in model. If model returns multiple values per sample, subsample along each dimension.\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.subsample-Tuple{Any, Any}","page":"ISOKANN.jl","title":"ISOKANN.subsample","text":"subsample(data, nx)\n\nreturn a random subsample of nx points from data \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.subsample_inds-Tuple{Any, Any, Any}","page":"ISOKANN.jl","title":"ISOKANN.subsample_inds","text":"subsample_inds(model, xs, n) :: Vector{Int}\n\nReturns n indices of xs such that model(xs[inds]) is approximately uniformly distributed.\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.subsample_uniformgrid-Tuple{Any, Any}","page":"ISOKANN.jl","title":"ISOKANN.subsample_uniformgrid","text":"subsbample_uniformgrid(ys, n) -> is\n\ngiven a list of values ys, return nindicesissuch thatys[is]` are approximately uniform by picking the closest points to a randomly perturbed grid in [0,1].\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.trajectory-Tuple{ISOKANN.AbstractLangevin}","page":"ISOKANN.jl","title":"ISOKANN.trajectory","text":"trajectory(l::AbstractLangevin; T=lagtime(l), x0=randx0(l), save_start=false, saveat=lagtime(l), dt=dt(l)) generate a trajectory of length T, starting at x0 with stepsize dt, saving the output every saveat time. \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.writechemfile-Tuple{Any, Matrix}","page":"ISOKANN.jl","title":"ISOKANN.writechemfile","text":"writechemfile(filename, data::Array{<:Any,2}; source)\n\nSave the coordinates in data to filename with source as template using the Chemfiles library\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.OpenMM.integrate_langevin","page":"ISOKANN.jl","title":"ISOKANN.OpenMM.integrate_langevin","text":"integrate_langevin(sim::OpenMMSimulation, x0=getcoords(sim); steps=steps(sim), F_ext::Union{Function,Nothing}=nothing, saveevery::Union{Int, nothing}=nothing)\n\nIntegrate the Langevin equations with a Euler-Maruyama scheme, allowing for external forces.\n\nFext: An additional force perturbation. It is expected to have the form Fext(F, x) and mutating the provided force F.\nsaveevery: If nothing, returns just the last point, otherwise returns an array saving every saveevery frame.\n\n\n\n\n\n","category":"function"},{"location":"#ISOKANN.OpenMM.set_random_velocities!-Tuple{Any, Any}","page":"ISOKANN.jl","title":"ISOKANN.OpenMM.set_random_velocities!","text":"mutates the state in sim \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.propagate-Union{Tuple{T}, Tuple{OpenMMSimulation, AbstractMatrix{T}, Any}} where T","page":"ISOKANN.jl","title":"ISOKANN.propagate","text":"propagate(s::OpenMMSimulation, x0::AbstractMatrix{T}, ny; nthreads=Threads.nthreads(), mmthreads=1) where {T}\n\nPropagates ny replicas of the OpenMMSimulation s from the inintial states x0.\n\nArguments\n\ns: An instance of the OpenMMSimulation type.\nx0: Matrix containing the initial states as columns\nny: The number of replicas to create.\n\nOptional Arguments\n\nnthreads: The number of threads to use for parallelization of multiple simulations.\nmmthreads: The number of threads to use for each OpenMM simulation. Set to \"gpu\" to use the GPU platform.\n\nNote: For CPU we observed better performance with nthreads = num cpus, mmthreads = 1 then the other way around. With GPU nthreads > 1 should be supported, but on our machine lead to slower performance then nthreads=1.\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.randx0-Tuple{OpenMMSimulation, Any}","page":"ISOKANN.jl","title":"ISOKANN.randx0","text":"generate n random inintial points for the simulation mm \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.savecoords-Union{Tuple{T}, Tuple{Any, OpenMMSimulation, AbstractArray{T}}} where T","page":"ISOKANN.jl","title":"ISOKANN.savecoords","text":"savecoords(path, sim::OpenMMSimulation, coords::AbstractArray{T})\n\nSave the given coordinates in a .pdb file using OpenMM\n\n\n\n\n\n","category":"method"}]
}
