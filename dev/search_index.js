var documenterSearchIndex = {"docs":
[{"location":"development/#Development","page":"Development","title":"Development","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"clone the repository with","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"git clone git@github.com:axsk/ISOKANN.jl.git","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"and create your own branch with","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"git checkout -b mynewcoolbranch.","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"Install julia, preferrably with juliaup (at least version 1.9). We recommend using Revise for a smoother dev experience.","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"Dont forget to activate the project with ]activate . and instantiate the dependencies with ]instantiate. You should then be able to run the tests with ]test or start using ISOKANN.","category":"page"},{"location":"#ISOKANN.jl","page":"ISOKANN.jl","title":"ISOKANN.jl","text":"","category":"section"},{"location":"","page":"ISOKANN.jl","title":"ISOKANN.jl","text":"Documentation for ISOKANN.jl","category":"page"},{"location":"","page":"ISOKANN.jl","title":"ISOKANN.jl","text":"CurrentModule = ISOKANN","category":"page"},{"location":"#Main-entry-points","page":"ISOKANN.jl","title":"Main entry points","text":"","category":"section"},{"location":"","page":"ISOKANN.jl","title":"ISOKANN.jl","text":"IsoRun\nISOKANN.run!\nMollyLangevin\npropagate","category":"page"},{"location":"#ISOKANN.IsoRun","page":"ISOKANN.jl","title":"ISOKANN.IsoRun","text":"struct IsoRun{T}\n\nThe IsoRun struct represents a configuration for running the ISOKANN algorithm with adaptive sampling.\n\nThe whole algorithm consists of three nested loop\n\nnd iterations of the data loop where nx points are subsampled (via stratified χ-subsampling)  from the pool of all available data\nnp iterations of the power iteration where the training target is determined with the current model and subdata\nnl iterations of the SGD updates to the neural network model to learn the current target\n\nOn initialization it samples ny starting positions with nk Koopman samples each.  Furthermore if nres > 0 it samples ny new data points adaptively starting from χ-sampled positions every nres steps in the data loop.\n\nThe sim field takes any simulation object that implements the data sampling interface (mainly the propagate method, see data.jl), usually a MollyLangevin simulation.\n\nmodel and opt store the neural network model and the optimizert (defaulting to a pairnet and AdamRegularized).\n\ndata contains the training data and is by default constructed using the bootstrap method.\n\nThe vector losses keeps track of the training loss and loggers allows to pass in logging functions which are executed in the power iteration loop.\n\nTo start the actual training call the run! method.\n\nFields\n\nnd::Int64: Number of outer data subsampling steps.\nnx::Int64: Size of subdata set.\nnp::Int64: Number of power iterations with the same subdata.\nnl::Int64: Number of weight updates with the same power iteration step.\nnres::Int64: Resample new data every n outer steps.\nny::Int64: Number of new points to sample.\nnk::Int64: Number of Koopman points to sample.\nnxmax::Int64: Maximal number of x data points.\nsim: Simulation object.\nmodel: Model object.\nopt: Optimization algorithm.\ndata::T: Data object.\nlosses: Vector to store loss values.\nloggers::Vector: Vector of loggers.\nminibatch::Int: Size of the (shuffled) minibatches. Set to 0 to disable\n\n\n\n\n\n","category":"type"},{"location":"#ISOKANN.run!","page":"ISOKANN.jl","title":"ISOKANN.run!","text":"run the given IsoRun object \n\n\n\n\n\n","category":"function"},{"location":"#ISOKANN.MollyLangevin","page":"ISOKANN.jl","title":"ISOKANN.MollyLangevin","text":"struct MollyLangevin{S<:Molly.System} <: IsoSimulation\n\nThe MollyLangevin struct represents a Langevin dynamics simulation for the Molly package.     It contains the system as well as the integration parameters.\n\nFields\n\nsys::S: The system to be simulated.\ntemp::Float64: The temperature of the simulation in Kelvin. Default is 298.0 K.\ngamma::Float64: The friction coefficient for the Langevin dynamics. Default is 1.0.\ndt::Float64: The time step size in picoseconds. Default is 2e-3 ps.\nT::Float64: The total simulation time in picoseconds. Default is 2e-1 ps.\nn_threads::Int: The number of threads for force computations. Default is 1.\n\n\n\n\n\n","category":"type"},{"location":"#ISOKANN.propagate","page":"ISOKANN.jl","title":"ISOKANN.propagate","text":"propagate(s::OpenMMSimulation, x0::AbstractMatrix{T}, ny; nthreads=Threads.nthreads(), mmthreads=1) where {T}\n\nPropagates ny replicas of the OpenMMSimulation s from the inintial states x0.\n\nArguments\n\ns: An instance of the OpenMMSimulation type.\nx0: Matrix containing the initial states as columns\nny: The number of replicas to create.\n\nOptional Arguments\n\nnthreads: The number of threads to use for parallelization of multiple simulations.\nmmthreads: The number of threads to use for each OpenMM simulation. Set to \"gpu\" to use the GPU platform.\n\n\n\n\n\npropagate(ms::MollyLangevin, x0::AbstractMatrix, ny)\n\nBurst simulation of the MollyLangeving system ms. Propagates ny samples for each initial position provided in the columns of x0.\n\npropagate is the main interface facilitating sampling of a system. TODO: specify the actual interface required for a simulation to be runnable by ISOKANN.\n\nArguments\n\nms::MollyLangevin: The MollyLangevin solver object.\nx0::AbstractMatrix: The initial positions matrix.\nny: The number of trajectories per initial condition.\n\nReturns\n\nys: A 3-dimensional array of size (dim(ms), nx, ny) containing the propagated solutions.\n\n\n\n\n\nFallback to simulate MD dynamics on the CPU \n\n\n\n\n\n","category":"function"},{"location":"#Public-API","page":"ISOKANN.jl","title":"Public API","text":"","category":"section"},{"location":"","page":"ISOKANN.jl","title":"ISOKANN.jl","text":"Modules = [ISOKANN]\nPrivate = false","category":"page"},{"location":"#ISOKANN.PDB_1UAO-Tuple{}","page":"ISOKANN.jl","title":"ISOKANN.PDB_1UAO","text":"Create a Molly system for the small Chignolin protein \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.PDB_ACEMD-Tuple{}","page":"ISOKANN.jl","title":"ISOKANN.PDB_ACEMD","text":"Create a Molly system for the alanine dipeptide without solvent \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.PDB_diala_water-Tuple{}","page":"ISOKANN.jl","title":"ISOKANN.PDB_diala_water","text":"Create a Molly system for the alanine dipeptide with water \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.iso2-Tuple{}","page":"ISOKANN.jl","title":"ISOKANN.iso2","text":"iso2(; n=1000, nx=100, ny=10, nd=2, sys=Doublewell(), lr=1e-2, decay=1e-5)\n\nISOKANN 2.0 under construction.\n\nArguments\n\nn: Number of iterations (default: 1000)\nnx: Number of start points (default: 100)\nny: Number of end points per start (default: 10)\nnd: Number of dimensions of the koopman function (default: 2)\nsys: System object (needs to support randx0, dim, propagate) (default: Doublewell())\nlr: Learning rate\ndecay: Decay rate\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.pairnet","page":"ISOKANN.jl","title":"ISOKANN.pairnet","text":"Fully connected neural network with layers layers from n to nout dimensions. features allows to pass a featurizer as preprocessor,  activation determines the activation function for each but the last layer lastactivation can be used to modify the last layers activation function \n\n\n\n\n\n","category":"function"},{"location":"#ISOKANN.pairnet-Tuple{Any}","page":"ISOKANN.jl","title":"ISOKANN.pairnet","text":"A pairnet() model with using the simulation's featureinds() particles pairwise positions as input for the first layer\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.propagate-Tuple{MollyLangevin, AbstractMatrix, Any}","page":"ISOKANN.jl","title":"ISOKANN.propagate","text":"propagate(ms::MollyLangevin, x0::AbstractMatrix, ny)\n\nBurst simulation of the MollyLangeving system ms. Propagates ny samples for each initial position provided in the columns of x0.\n\npropagate is the main interface facilitating sampling of a system. TODO: specify the actual interface required for a simulation to be runnable by ISOKANN.\n\nArguments\n\nms::MollyLangevin: The MollyLangevin solver object.\nx0::AbstractMatrix: The initial positions matrix.\nny: The number of trajectories per initial condition.\n\nReturns\n\nys: A 3-dimensional array of size (dim(ms), nx, ny) containing the propagated solutions.\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.propagate-Tuple{MollyLangevin, CUDA.CuArray{T, 2} where T, Any}","page":"ISOKANN.jl","title":"ISOKANN.propagate","text":"Fallback to simulate MD dynamics on the CPU \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.reactionpath-Tuple{Any, Any, Any}","page":"ISOKANN.jl","title":"ISOKANN.reactionpath","text":"compute the reactionpath for the simulation sim starting in x0 along the gradient of the function provided by chi\n\nOptional arguments: extrapolate: walk beyond the interval limits orth: factor for the force orthogonal to the chi gradient solver: the ODE solver to use dt: the timestep size kwargs...: Keyword arguments passed to the solve method\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.run!-Tuple{IsoRun}","page":"ISOKANN.jl","title":"ISOKANN.run!","text":"run the given IsoRun object \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.solve-Tuple{Any}","page":"ISOKANN.jl","title":"ISOKANN.solve","text":"sample a single trajectory for the given system \n\n\n\n\n\n","category":"method"},{"location":"#Internal-API","page":"ISOKANN.jl","title":"Internal API","text":"","category":"section"},{"location":"","page":"ISOKANN.jl","title":"ISOKANN.jl","text":"Modules = [ISOKANN]\nPublic = false","category":"page"},{"location":"#ISOKANN.ChiStratData","page":"ISOKANN.jl","title":"ISOKANN.ChiStratData","text":"dataset type handling chi-stratified subsampling and traindata-subsampling\n\n\n\n\n\n","category":"type"},{"location":"#ISOKANN.DataTuple","page":"ISOKANN.jl","title":"ISOKANN.DataTuple","text":"DataTuple = Tuple{Matrix{T},Array{T,3}} where {T<:Number}\n\nWe represent data as a tuple of xs and ys.\n\nxs is a matrix of size (d, n) where d is the dimension of the system and n the number of samples. ys is a tensor of size (d, n, k) where k is the number of koopman samples.\n\n\n\n\n\n","category":"type"},{"location":"#ISOKANN.MutTuple","page":"ISOKANN.jl","title":"ISOKANN.MutTuple","text":"a tuple which allows mutation and creation of new fields\n\n\n\n\n\n","category":"type"},{"location":"#ISOKANN.OverdampedLangevinGirsanov","page":"ISOKANN.jl","title":"ISOKANN.OverdampedLangevinGirsanov","text":"OverdampedLangevinGirsanov(; <keyword arguments>)\n\nSimulates the overdamped Langevin equation using the Euler-Maruyama method with an auxilliary control w/u with σ = sqrt(2KT/(mγ)) dX = (-∇U(X)/(γm) + σu) dt + σ dW\n\nwhere u is the control function, such that u(x,t) = σ .* w(x,t). The accumulated Girsanov reweighting is stored in the field g\n\nArguments\n\ndt::S: the time step of the simulation.\ntemperature::K: the equilibrium temperature of the simulation.\nfriction::F: the friction coefficient of the simulation.\nremove_CM_motion=1: remove the center of mass motion every this number of steps,   set to false or 0 to not remove center of mass motion.\nw::Function: the control function, such that u(x,t) = σ .* w(x,t)\n\n\n\n\n\n","category":"type"},{"location":"#ISOKANN.TransformISA","page":"ISOKANN.jl","title":"ISOKANN.TransformISA","text":"TransformISA(permute)\n\nCompute the target via the inner simplex algorithm (without feasiblization routine). permute specifies whether to apply the stabilizing permutation \n\n\n\n\n\n","category":"type"},{"location":"#ISOKANN.TransformPseudoInv","page":"ISOKANN.jl","title":"ISOKANN.TransformPseudoInv","text":"TransformPseudoInv(normalize, direct, eigenvecs, permute)\n\nCompute the target by approximately inverting the action of K with the Moore-Penrose pseudoinverse.\n\nIf direct==true solve chi * pinv(K(chi)), otherwise inv(K(chi) * pinv(chi))). eigenvecs specifies whether to use the eigenvectors of the schur matrix. normalize specifies whether to renormalize the resulting target vectors. permute specifies whether to permute the target for stability.\n\n\n\n\n\n","category":"type"},{"location":"#ISOKANN.TransformShiftscale","page":"ISOKANN.jl","title":"ISOKANN.TransformShiftscale","text":"TransformShiftscale()\n\nClassical 1D shift-scale (ISOKANN 1) \n\n\n\n\n\n","category":"type"},{"location":"#ISOKANN._pickclosestloop-Tuple{AbstractVector, AbstractVector}","page":"ISOKANN.jl","title":"ISOKANN._pickclosestloop","text":"scales with n=length(hs) \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.adddata-NTuple{4, Any}","page":"ISOKANN.jl","title":"ISOKANN.adddata","text":"adddata(data::D, model, sim, ny, lastn=1_000_000)::D\n\nGenerate new data for ISOKANN by adaptive subsampling using the chi-stratified/-uniform method.\n\nAdaptively subsample ny points from data uniformly along their model values.\npropagate according to the simulation model.\nreturn the newly obtained data concatenated to the input data\n\nThe subsamples are taken only from the lastn last datapoints in data.\n\nExamples\n\njulia> (xs, ys) = adddata((xs,ys), chi, mollysim)\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.bootstrap-Tuple{ISOKANN.IsoSimulation, Any, Any}","page":"ISOKANN.jl","title":"ISOKANN.bootstrap","text":"bootstrap(sim, nx, ny) :: DataTuple\n\ncompute initial data by propagating the molecules initial state to obtain the xs and propagating them further for the ys \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.centercoords-Tuple{Any}","page":"ISOKANN.jl","title":"ISOKANN.centercoords","text":"centercoords any given states by shifting their individual 3d mean to the origin\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.chi_exit_rate-Tuple{Any, Any, Any}","page":"ISOKANN.jl","title":"ISOKANN.chi_exit_rate","text":"compute the chi exit rate as per Ernst, Weber (2017), chap. 3.3 \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.data_from_trajectory-Tuple{Matrix}","page":"ISOKANN.jl","title":"ISOKANN.data_from_trajectory","text":"data_from_trajectory(xs::Matrix; reverse=false) :: DataTuple\n\nGenerate the lag-1 data from the trajectory xs. If reverse is true, also take the time-reversed lag-1 data.\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.diala2-Tuple{}","page":"ISOKANN.jl","title":"ISOKANN.diala2","text":"ISOKANN 2 dialanine experiment generates data from 1d ISOKANN and trains a 3d ISOKANN on it\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.eigenvalue-Tuple{Any, Any}","page":"ISOKANN.jl","title":"ISOKANN.eigenvalue","text":"estimate the eigenvalue of the chi function at the extrema of the data \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.eigenvalue_regression-Tuple{Any, Any}","page":"ISOKANN.jl","title":"ISOKANN.eigenvalue_regression","text":"estimate the eigenvalue of the chi function by regression over all data \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.exportdata","page":"ISOKANN.jl","title":"ISOKANN.exportdata","text":"exportdata(data::AbstractArray, model, sys, path=\"out/data.pdb\")\n\nExport data to a PDB file.\n\nThis function takes an AbstractArray data, sorts it according to the model evaluation, removes duplicates, transforms it to standard form and saves it as a PDB file  to path.\n\n\n\n\n\n","category":"function"},{"location":"#ISOKANN.fixperm-Tuple{Any, Any}","page":"ISOKANN.jl","title":"ISOKANN.fixperm","text":"fixperm(new, old)\n\nPermutes the rows of new such as to minimize L1 distance to old.\n\nArguments\n\nnew: The data to match to the reference data.\nold: The reference data.\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.flatpairdists-Tuple{Any}","page":"ISOKANN.jl","title":"ISOKANN.flatpairdists","text":"Threaded computation of pairwise dists for x::AbstractArray. Assumes each col of x to be a flattened representation of multiple 3d coords. Returns the flattened pairwise distances as columns.\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.getcoords-Tuple{Molly.System}","page":"ISOKANN.jl","title":"ISOKANN.getcoords","text":"extract the unitful SVector coords from sys and return as a normal vector \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.gpu-Tuple{IsoRun}","page":"ISOKANN.jl","title":"ISOKANN.gpu","text":"gpu(iso::IsoRun)\n\nmove the model and data of the given IsoRun to the GPU for CUDA support\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.gpu-Tuple{Molly.System}","page":"ISOKANN.jl","title":"ISOKANN.gpu","text":"move the ::System to the GPU, mirroring behavior of Flux.gpu \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.growmodel-Tuple{Any, Any}","page":"ISOKANN.jl","title":"ISOKANN.growmodel","text":"Given a model and return a copy with its last layer replaced with given output dimension n \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.inputdim-Tuple{Flux.Chain}","page":"ISOKANN.jl","title":"ISOKANN.inputdim","text":"obtain the input dimension of a Flux model \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.isokann-NTuple{4, Any}","page":"ISOKANN.jl","title":"ISOKANN.isokann","text":"ISOKANN with advanced data handling, dataset handles possible resampling of data\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.isokann-Tuple{IsoRun}","page":"ISOKANN.jl","title":"ISOKANN.isokann","text":"wrap the old ISORun into the simplified isokann() call\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.isokann_simple-NTuple{4, Any}","page":"ISOKANN.jl","title":"ISOKANN.isokann_simple","text":"bare bones ISOKANN, for educational purposes model is a Flux neural network, opt an Optimiser, data a tuple of (x,y) coordinates, n the number of iterations\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.isosteps","page":"ISOKANN.jl","title":"ISOKANN.isosteps","text":"isostep(model, opt, (xs, ys), nkoop=1, nupdate=1; transform = TransformISA())\n\ntrain the model on a given batch of trajectory data (xs, ys) with\n\nnkoop: outer iterations, i.e. reevaluating Koopman\nnupdate: inner iterations, i.e. updating the neural network on fixed data\n\n\n\n\n\n","category":"function"},{"location":"#ISOKANN.koopman-Tuple{Any, Any}","page":"ISOKANN.jl","title":"ISOKANN.koopman","text":"evluation of koopman by shiftscale(mean(model(data))) on the data \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.learnbatch!-Tuple{Any, AbstractMatrix, AbstractVector, Any, Any}","page":"ISOKANN.jl","title":"ISOKANN.learnbatch!","text":"DEPRECATED - batched supervised learning for a given batchsize \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.learnstep!-Tuple{Any, AbstractMatrix, AbstractMatrix, Any}","page":"ISOKANN.jl","title":"ISOKANN.learnstep!","text":"single supervised learning step \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.mean_speed-Tuple{Any, Any, Any}","page":"ISOKANN.jl","title":"ISOKANN.mean_speed","text":"what is the mean speed for a given force \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.model_with_opt","page":"ISOKANN.jl","title":"ISOKANN.model_with_opt","text":"convenience wrapper returning the provided model with the default AdamW optimiser \n\n\n\n\n\n","category":"function"},{"location":"#ISOKANN.outputdim-Tuple{Flux.Chain}","page":"ISOKANN.jl","title":"ISOKANN.outputdim","text":"Obtain the output dimension of a Flux model \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.pickclosest_sort-Tuple{AbstractVector, AbstractVector}","page":"ISOKANN.jl","title":"ISOKANN.pickclosest_sort","text":"pickclosest(haystack, needles)\n\nReturn the indices into haystack which lie closest to needles without duplicates by removing haystack candidates after a match. Note that this is not invariant under pertubations of needles\n\nscales with n log(n) m where n=length(haystack), m=length(needles) \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.plotatoms!","page":"ISOKANN.jl","title":"ISOKANN.plotatoms!","text":"scatter plot of all first \"O\" atoms of the starting points xs as well as the \"O\" atoms from the koopman samples to the first point from ys\n\n\n\n\n\n","category":"function"},{"location":"#ISOKANN.plotlossdata","page":"ISOKANN.jl","title":"ISOKANN.plotlossdata","text":"combined plot of loss graph and current atoms \n\n\n\n\n\n","category":"function"},{"location":"#ISOKANN.rotationhandles-Tuple{Molly.System}","page":"ISOKANN.jl","title":"ISOKANN.rotationhandles","text":"Return the rotation handle indices for the standardform of a molecule\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.scaleandshift-Tuple{Any, Any, Any}","page":"ISOKANN.jl","title":"ISOKANN.scaleandshift","text":"scaleandshift(model, xs, ys)\n\nEstimate the scale and shift parameters using linear regression\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.scatter_chifix-Tuple{Any, Any}","page":"ISOKANN.jl","title":"ISOKANN.scatter_chifix","text":"fixed point plot, i.e. x vs model(x) \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.selectrows-Tuple{Any, Any}","page":"ISOKANN.jl","title":"ISOKANN.selectrows","text":"given an array of arbitrary shape, select the rows inds in the first dimension \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.shiftscale-Tuple{Any}","page":"ISOKANN.jl","title":"ISOKANN.shiftscale","text":"empirical shift-scale operation \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.sigma","page":"ISOKANN.jl","title":"ISOKANN.sigma","text":"return the diagonal of the noise factor sigma of the brownian dynamics \n\n\n\n\n\n","category":"function"},{"location":"#ISOKANN.subsample-Tuple{Any, AbstractMatrix, Any}","page":"ISOKANN.jl","title":"ISOKANN.subsample","text":"subsample(model, data::Array, n) :: Matrix\nsubsample(model, data::Tuple, n) :: Tuple\n\nSubsample n points of data uniformly in model. If model returns multiple values per sample, subsample along each dimension.\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.subsample-Tuple{Any, Any}","page":"ISOKANN.jl","title":"ISOKANN.subsample","text":"subsample(data, nx)\n\nreturn a random subsample of nx points from data \n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.subsample_inds-Tuple{Any, Any, Any}","page":"ISOKANN.jl","title":"ISOKANN.subsample_inds","text":"subsample_inds(model, xs, n) :: Vector{Int}\n\nReturns n indices of xs such that model(xs[inds]) is approximately uniformly distributed.\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.subsample_uniformgrid-Tuple{Any, Any}","page":"ISOKANN.jl","title":"ISOKANN.subsample_uniformgrid","text":"subsbample_uniformgrid(ys, n) -> is\n\ngiven a list of values ys, return nindicesissuch thatys[is]` are approximately uniform by picking the closest points to a randomly perturbed grid in [0,1].\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.trajectory-Tuple{Any, Any}","page":"ISOKANN.jl","title":"ISOKANN.trajectory","text":"trajectory(sim, nx) generate a trajectory of length nx from the simulation sim\n\n\n\n\n\n","category":"method"},{"location":"#ISOKANN.vec_to_coords-Tuple{AbstractArray, Molly.System}","page":"ISOKANN.jl","title":"ISOKANN.vec_to_coords","text":"convert normal vector of coords to SVectors of unitful system coords \n\n\n\n\n\n","category":"method"}]
}
