<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ISOKANN.jl · ISOKANN</title><meta name="title" content="ISOKANN.jl · ISOKANN"/><meta property="og:title" content="ISOKANN.jl · ISOKANN"/><meta property="twitter:title" content="ISOKANN.jl · ISOKANN"/><meta name="description" content="Documentation for ISOKANN."/><meta property="og:description" content="Documentation for ISOKANN."/><meta property="twitter:description" content="Documentation for ISOKANN."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>ISOKANN</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>ISOKANN.jl</a><ul class="internal"><li><a class="tocitem" href="#Main-entry-points"><span>Main entry points</span></a></li><li><a class="tocitem" href="#Models-and-Optimizers"><span>Models and Optimizers</span></a></li><li><a class="tocitem" href="#Public-API"><span>Public API</span></a></li><li><a class="tocitem" href="#Internal-API"><span>Internal API</span></a></li></ul></li><li><a class="tocitem" href="installation/">Installation</a></li><li><a class="tocitem" href="introduction/">Introduction</a></li><li><a class="tocitem" href="isomu/">IsoMu</a></li><li><a class="tocitem" href="tips/">Tips and tricks</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>ISOKANN.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>ISOKANN.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/axsk/ISOKANN.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/axsk/ISOKANN.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ISOKANN.jl"><a class="docs-heading-anchor" href="#ISOKANN.jl">ISOKANN.jl</a><a id="ISOKANN.jl-1"></a><a class="docs-heading-anchor-permalink" href="#ISOKANN.jl" title="Permalink"></a></h1><p>Documentation for ISOKANN.jl</p><h2 id="Main-entry-points"><a class="docs-heading-anchor" href="#Main-entry-points">Main entry points</a><a id="Main-entry-points-1"></a><a class="docs-heading-anchor-permalink" href="#Main-entry-points" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="ISOKANN.OpenMM.OpenMMSimulation"><a class="docstring-binding" href="#ISOKANN.OpenMM.OpenMMSimulation"><code>ISOKANN.OpenMM.OpenMMSimulation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">OpenMMSimulation(; pdb, steps, ...)
OpenMMSimulation(; py, steps)</code></pre><p>Constructs an OpenMM simulation object. Either use  <code>OpenMMSimulation(;py, steps)</code> where <code>py</code><code>is the location of a .py python script creating a OpenMM simulation object or supply a .pdb file via</code>pdb` and the following parameters (see also defaultsystem):</p><p><strong>Arguments</strong></p><ul><li><code>pdb::String</code>: Path to the PDB file.</li><li><code>ligand::String</code>: Path to ligand file.</li><li><code>forcefields::Vector{String}</code>: List of force field XML files.</li><li><code>temp::Float64</code>: Temperature in Kelvin.</li><li><code>friction::Float64</code>: Friction coefficient in 1/picosecond.</li><li><code>step::Float64</code>: Integration step size in picoseconds.</li><li><code>steps::Int</code>: Number of simulation steps.</li><li><code>features</code>: Which features to use for learning the chi function.             -  A vector of <code>Int</code> denotes the indices of all atoms to compute the pairwise distances from.             -  A vector of CartesianIndex{2} computes the specific distances between the atom pairs.             -  A number denotes the radius below which all pairs of atoms will be used (computed only on the starting configuration)             -  If <code>nothing</code> all pairwise distances are used.</li><li><code>minimize::Bool</code>: Whether to perform energy minimization on first state.</li><li><code>nthreads</code>: The number of threads to use for parallelization of multiple simulations.</li><li><code>mmthreads</code>: The number of threads to use for each OpenMM simulation. Set to &quot;gpu&quot; to use the GPU platform.</li></ul><p><strong>Returns</strong></p><ul><li><code>OpenMMSimulation</code>: An OpenMMSimulation object.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/simulators/openmm.jl#L51-L79">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.SimulationData"><a class="docstring-binding" href="#ISOKANN.SimulationData"><code>ISOKANN.SimulationData</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct SimulationData{S,D,C,F}</code></pre><p>A struct combining a simulation with the simulated coordinates and corresponding ISOKANN trainingsdata</p><p><strong>Fields</strong></p><ul><li><code>sim::S</code>: The simulation object.</li><li><code>data::D</code>: The ISOKANN trainings data.</li><li><code>coords::C</code>: The orginal coordinates of the simulations.</li><li><code>featurizer::F</code>: A function mapping coordinates to ISOKANN features.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/simulation.jl#L50-L61">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.Iso"><a class="docstring-binding" href="#ISOKANN.Iso"><code>ISOKANN.Iso</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Iso(data; opt=NesterovRegularized(), model=defaultmodel(data), gpu=false, kwargs...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/iso.jl#L13-L16">source</a></section><section><div><pre><code class="language-julia hljs">Iso(sim::IsoSimulation; nx=100, nk=10, nd=1, kwargs...)</code></pre><p>Convenience constructor which generates the <code>SimulationData</code> from the simulation <code>sim</code> and constructs the Iso object. See also Iso(data; kwargs...)</p><p><strong>Arguments</strong></p><ul><li><code>sim::IsoSimulation</code>: The <code>IsoSimulation</code> object.</li><li><code>nx::Int</code>: The number of starting points.</li><li><code>nk::Int</code>: The number of koopman samples.</li><li><code>nout::Int</code>: Dimension of the χ function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/iso.jl#L45-L56">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.propagate"><a class="docstring-binding" href="#ISOKANN.propagate"><code>ISOKANN.propagate</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">propagate(sim::OpenMMSimulation, x0::AbstractMatrix, nk)</code></pre><p>Propagates <code>nk</code> replicas of the OpenMMSimulation <code>sim</code> from the inintial states <code>x0</code>.</p><p><strong>Arguments</strong></p><ul><li><code>sim</code>: An OpenMMSimulation object.</li><li><code>x0</code>: Matrix containing the initial states as columns</li><li><code>nk</code>: The number of replicas to create.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/simulators/openmm.jl#L252-L262">source</a></section></details></article><div class="admonition is-warning" id="Missing-docstring.-f1f8768f0850a9af"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-f1f8768f0850a9af" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>isodata</code>. Check Documenter&#39;s build log for details.</p></div></div><article><details class="docstring" open="true"><summary id="ISOKANN.run!"><a class="docstring-binding" href="#ISOKANN.run!"><code>ISOKANN.run!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">run!(iso::Iso, n=1, epochs=1)</code></pre><p>Run the training process for the Iso model.</p><p><strong>Arguments</strong></p><p>a <code>iso::Iso</code>: The Iso model to train.</p><ul><li><code>n::Int</code>: The number of (outer) Koopman iterations.</li><li><code>epochs::Int</code>: The number of (inner) epochs to train the model for each Koopman evaluation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/iso.jl#L62-L71">source</a></section></details></article><div class="admonition is-warning" id="Missing-docstring.-91d758386cb535a0"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-91d758386cb535a0" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>plot_training</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Models-and-Optimizers"><a class="docs-heading-anchor" href="#Models-and-Optimizers">Models and Optimizers</a><a id="Models-and-Optimizers-1"></a><a class="docs-heading-anchor-permalink" href="#Models-and-Optimizers" title="Permalink"></a></h2><div class="admonition is-warning" id="Missing-docstring.-b1917a6fdfdaecea"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-b1917a6fdfdaecea" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>defaultmodel</code>. Check Documenter&#39;s build log for details.</p></div></div><article><details class="docstring" open="true"><summary id="ISOKANN.pairnet"><a class="docstring-binding" href="#ISOKANN.pairnet"><code>ISOKANN.pairnet</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Fully connected neural network with <code>layers</code> layers from <code>n</code> to <code>nout</code> dimensions. <code>activation</code> determines the activation function for each but the last layer <code>lastactivation</code> can be used to modify the last layers activation function </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/models.jl#L62-L65">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.densenet"><a class="docstring-binding" href="#ISOKANN.densenet"><code>ISOKANN.densenet</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">densenet(; layers::Vector{Int}, activation=Flux.sigmoid, lastactivation=identity, layernorm=true) -&gt; Flux.Chain</code></pre><p>Construct a fully connected neural network (<code>Flux.Chain</code>) with customizable layer sizes, activations,  and optional input layer normalization.</p><p><strong>Arguments</strong></p><ul><li><code>layers::Vector{Int}</code>: List of layer dimensions. For example, <code>[10, 32, 16, 1]</code> creates a network with input size 10, two hidden layers of size 32 and 16, and an output layer of size 1.</li><li><code>activation</code>: Activation function applied to all layers except the last. Defaults to <code>Flux.sigmoid</code>.</li><li><code>lastactivation</code>: Activation function for the final layer. Defaults to <code>identity</code>.</li><li><code>layernorm::Bool</code>: Whether to prepend a <code>Flux.LayerNorm</code> layer to normalize the input. Defaults to <code>true</code>.</li></ul><p><strong>Returns</strong></p><p>A <code>Flux.Chain</code> composed of dense layers (and optionally a leading <code>LayerNorm</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/models.jl#L71-L86">source</a></section></details></article><div class="admonition is-warning" id="Missing-docstring.-9947270f464ac54c"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-9947270f464ac54c" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>smallnet</code>. Check Documenter&#39;s build log for details.</p></div></div><article><details class="docstring" open="true"><summary id="ISOKANN.AdamRegularized"><a class="docstring-binding" href="#ISOKANN.AdamRegularized"><code>ISOKANN.AdamRegularized</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">AdamRegularized(adam=1e-3, reg=1e-4)</code></pre><p>Constructs an optimizer that combines weight decay regularization with ADAM. Uses <code>reg</code> for the weight decay parameter and <code>lr</code> as the learning rate for ADAM. Note that this is different from AdamW (Adam+WeightDecay) (c.f. Decay vs L2 Reg.). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/models.jl#L6-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.NesterovRegularized"><a class="docstring-binding" href="#ISOKANN.NesterovRegularized"><code>ISOKANN.NesterovRegularized</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">NesterovRegularized(; lr=1e-3, reg=1e-4)</code></pre><p>Constructs an optimizer that combines weight decay regularization with Nesterov momentum. Uses <code>reg</code> for the weight decay parameter and <code>lr</code> as the learning rate for Nesterov acceleration. This worked well as alternative where ADAM had problems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/models.jl#L14-L19">source</a></section></details></article><h2 id="Public-API"><a class="docs-heading-anchor" href="#Public-API">Public API</a><a id="Public-API-1"></a><a class="docs-heading-anchor-permalink" href="#Public-API" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="ISOKANN.Iso-Tuple{Any}"><a class="docstring-binding" href="#ISOKANN.Iso-Tuple{Any}"><code>ISOKANN.Iso</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Iso(data; opt=NesterovRegularized(), model=defaultmodel(data), gpu=false, kwargs...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/iso.jl#L13-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.Iso-Tuple{ISOKANN.IsoSimulation}"><a class="docstring-binding" href="#ISOKANN.Iso-Tuple{ISOKANN.IsoSimulation}"><code>ISOKANN.Iso</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Iso(sim::IsoSimulation; nx=100, nk=10, nd=1, kwargs...)</code></pre><p>Convenience constructor which generates the <code>SimulationData</code> from the simulation <code>sim</code> and constructs the Iso object. See also Iso(data; kwargs...)</p><p><strong>Arguments</strong></p><ul><li><code>sim::IsoSimulation</code>: The <code>IsoSimulation</code> object.</li><li><code>nx::Int</code>: The number of starting points.</li><li><code>nk::Int</code>: The number of koopman samples.</li><li><code>nout::Int</code>: Dimension of the χ function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/iso.jl#L45-L56">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.SimulationData-Tuple{ISOKANN.IsoSimulation, Int64, Int64}"><a class="docstring-binding" href="#ISOKANN.SimulationData-Tuple{ISOKANN.IsoSimulation, Int64, Int64}"><code>ISOKANN.SimulationData</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SimulationData(sim::IsoSimulation, nx::Int, nk::Int; ...)
SimulationData(sim::IsoSimulation, xs::AbstractMatrix, nk::Int; ...)
SimulationData(sim::IsoSimulation, (xs,ys); ...)
SimulationData(xs, ys; pdb=&quot;&quot;, ...)  # for external simulation data</code></pre><p>Generates SimulationData from a simulation with either</p><ul><li><code>nx</code> initial points and <code>nk</code> Koopman samples</li><li><code>xs</code> as initial points and <code>nk</code> Koopman sample</li><li><code>xs</code> as inintial points and <code>ys</code> as Koopman samples</li><li><code>xs</code> and <code>ys</code> from external simulations</li><li><code>xs</code> a trajectory of an external simulation, implicitly computing ys via <code>data_from_trajectory</code> of succesive samples</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/simulation.jl#L70-L82">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.AdamRegularized"><a class="docstring-binding" href="#ISOKANN.AdamRegularized"><code>ISOKANN.AdamRegularized</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">AdamRegularized(adam=1e-3, reg=1e-4)</code></pre><p>Constructs an optimizer that combines weight decay regularization with ADAM. Uses <code>reg</code> for the weight decay parameter and <code>lr</code> as the learning rate for ADAM. Note that this is different from AdamW (Adam+WeightDecay) (c.f. Decay vs L2 Reg.). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/models.jl#L6-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.NesterovRegularized"><a class="docstring-binding" href="#ISOKANN.NesterovRegularized"><code>ISOKANN.NesterovRegularized</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">NesterovRegularized(; lr=1e-3, reg=1e-4)</code></pre><p>Constructs an optimizer that combines weight decay regularization with Nesterov momentum. Uses <code>reg</code> for the weight decay parameter and <code>lr</code> as the learning rate for Nesterov acceleration. This worked well as alternative where ADAM had problems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/models.jl#L14-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.ca_rmsd"><a class="docstring-binding" href="#ISOKANN.ca_rmsd"><code>ISOKANN.ca_rmsd</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ca_rmsd(cainds, pdb=&quot;data/villin nowater.pdb&quot;, pdbref=&quot;data/villin/1yrf.pdb&quot;)</code></pre><p>Returns a <code>ReactionCoordsRMSD</code> object which is used to calculate the Root Mean Square Deviation (RMSD) of the provided C-alpha atoms.</p><p>Inputs:     - cainds: Indices of the C-alpha atoms to consider for the RMSD     - target: PDB File containing the target structure to which the RMSD is computed     - source: Alternative PDB File for the source coordinates in the case that the indices differ (i.e. when matching different topologies)</p><p>Example:     rsmd = ca_rmsd(3:10, &quot;data/villin/1yrf.pdb&quot;, &quot;data/villin nowater.pdb&quot;)     rmsd(rand(300,10))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/molutils.jl#L242-L255">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.data_from_trajectory-Tuple{AbstractMatrix}"><a class="docstring-binding" href="#ISOKANN.data_from_trajectory-Tuple{AbstractMatrix}"><code>ISOKANN.data_from_trajectory</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">data_from_trajectory(xs::AbstractMatrix; reverse=true, stride=1, lag=1)</code></pre><p>Generate the (x,y) data pairs for ISOKANN from the trajectory <code>xs</code>.</p><p><code>stride</code> controls the stride of the starting positions x and <code>lag</code> the lag for the end positions <code>y</code> in terms of trajectory frames. If <code>reverse</code> is true, construct also the time-reversed pairs (recomended for stable ISOKANN training).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/data.jl#L80-L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.laggedtrajectory-Tuple{SimulationData, Any}"><a class="docstring-binding" href="#ISOKANN.laggedtrajectory-Tuple{SimulationData, Any}"><code>ISOKANN.laggedtrajectory</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">laggedtrajectory(data::SimulationData, n) = laggedtrajectory(data.sim, n, x0=coords(data)[:, end])</code></pre><p>Simulate a trajectory comprising of <code>n</code> simulations from the last point in <code>data</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/simulation.jl#L248-L252">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.load_trajectory-Tuple{Any}"><a class="docstring-binding" href="#ISOKANN.load_trajectory-Tuple{Any}"><code>ISOKANN.load_trajectory</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">load_trajectory(filename; top=nothing, kwargs...)</code></pre><p>wrapper around Python&#39;s <code>mdtraj.load()</code>. Returns a (3 * natom, nframes) shaped array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/molutils.jl#L69-L74">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.localpdistinds-Tuple{AbstractMatrix, Any}"><a class="docstring-binding" href="#ISOKANN.localpdistinds-Tuple{AbstractMatrix, Any}"><code>ISOKANN.localpdistinds</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">localpdistinds(coords::AbstractMatrix, radius)</code></pre><p>Given <code>coords</code> of shape ( 3n x frames ) return the pairs of indices whose minimal distance along all frames is at least once lower then radius</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/pairdists.jl#L71-L75">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.mergedata-Tuple{SimulationData, SimulationData}"><a class="docstring-binding" href="#ISOKANN.mergedata-Tuple{SimulationData, SimulationData}"><code>ISOKANN.mergedata</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mergedata(d1::SimulationData, d2::SimulationData)</code></pre><p>Merge the data and features of <code>d1</code> and <code>d2</code>, keeping the simulation and features of <code>d1</code>. Note that there is no check if simulation features agree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/simulation.jl#L146-L151">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.pairnet-Tuple{}"><a class="docstring-binding" href="#ISOKANN.pairnet-Tuple{}"><code>ISOKANN.pairnet</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Fully connected neural network with <code>layers</code> layers from <code>n</code> to <code>nout</code> dimensions. <code>activation</code> determines the activation function for each but the last layer <code>lastactivation</code> can be used to modify the last layers activation function </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/models.jl#L62-L65">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.pdists-Union{Tuple{T}, Tuple{AbstractMatrix, Array{Tuple{T, T}, 1}}} where T"><a class="docstring-binding" href="#ISOKANN.pdists-Union{Tuple{T}, Tuple{AbstractMatrix, Array{Tuple{T, T}, 1}}} where T"><code>ISOKANN.pdists</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">pdists(coords::AbstractArray, inds::Vector{&lt;:Tuple})</code></pre><p>Compute the pairwise distances between the particles specified by the tuples <code>inds</code> over all frames in <code>traj</code>. Assumes a column contains all 3n coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/pairdists.jl#L98-L103">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.picking-Tuple{Any, Any}"><a class="docstring-binding" href="#ISOKANN.picking-Tuple{Any, Any}"><code>ISOKANN.picking</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">picking(X, n; dists = pairwise_one_to_many)</code></pre><p>The picking algorithm, i.e. greedy farthest point sampling, for <code>n</code> points on the columns of <code>X</code>. A custom distance function (::Vector, ::Matrix)-&gt;(::Vector) may be passed through <code>dists</code>.</p><p>Returns <code>X[:,qs]</code>, i.e. the picked samples, their former indices <code>qs</code> and their distances <code>d</code> to all other points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/picking.jl#L8-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.reactionpath_minimum"><a class="docstring-binding" href="#ISOKANN.reactionpath_minimum"><code>ISOKANN.reactionpath_minimum</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">reactionpath_minimum(iso::Iso, x0; steps=100)</code></pre><p>Compute the reaction path by integrating ∇χ with orthogonal energy minimization.</p><p><strong>Arguments</strong></p><ul><li><code>iso::Iso</code>: The isomer for which the reaction path minimum is to be computed.</li><li><code>x0</code>: The starting point for the reaction path computation.</li><li><code>steps=100</code>: The number of steps to take along the reaction path.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/minimumpath.jl#L23-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.reactionpath_ode-Tuple{Any, Any}"><a class="docstring-binding" href="#ISOKANN.reactionpath_ode-Tuple{Any, Any}"><code>ISOKANN.reactionpath_ode</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">reactionpath_ode(iso, x0; steps=101, extrapolate=0, orth=0.01, solver=OrdinaryDiffEq.Tsit5(), dt=1e-3, kwargs...)</code></pre><p>Compute the reaction path by integrating ∇χ as well as <code>orth</code> * F orthogonal to ∇χ where F is the original force field.</p><p><strong>Arguments</strong></p><ul><li><code>iso::Iso</code>: The isomer for which the reaction path minimum is to be computed.</li><li><code>x0</code>: The starting point for the reaction path computation.</li><li><code>steps=100</code>: The number of steps to take along the reaction path.</li><li><code>minimize=false</code>: Whether to minimize the orthogonal to ∇χ before integration.</li><li><code>extrapolate=0</code>: How fast to extrapolate beyond χ 0 and 1.</li><li><code>orth=0.01</code>: The weight of the orthogonal force field.</li><li><code>solver=OrdinaryDiffEq.Tsit5()</code>: The solver to use for the ODE integration.</li><li><code>dt=1e-3</code>: The initial time step for the ODE integration.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/minimumpath.jl#L80-L95">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.reactive_path-Tuple{AbstractVector, AbstractMatrix}"><a class="docstring-binding" href="#ISOKANN.reactive_path-Tuple{AbstractVector, AbstractMatrix}"><code>ISOKANN.reactive_path</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>reactive_path(xi::AbstractVector, coords::AbstractMatrix; sigma, minjump=0, maxjump=1, method=QuantilePath(0.05), normalize=false, sortincreasing=true)</p><p>Find the maximum likelihood path (under the model of brownion motion with noise <code>sigma</code>) through <code>coords</code> with times <code>xi</code>. Supports either CPU or GPU arrays.</p><p><strong>Arguments</strong></p><ul><li><code>coords</code>:  (ndim x npoints) matrix of coordinates.</li><li><code>xi</code>: time coordinate of the npoints points</li><li><code>sigma</code>: spatial noise strength of the model.</li><li><code>minjump</code>, <code>maxjump</code>: lower and upper bound to the jump in time <code>xi</code> along the path. Tighter bounds reduce the computational cost.</li><li><code>method</code>: either <code>FromToPath</code>,  <code>QuantilePath</code>, <code>FullPath</code> or <code>MaxPath</code>, specifying the end points of the path</li><li><code>normalize</code>: whether to normalize all <code>coords</code> first</li><li><code>sortincreasing</code>: return the path from lower to higher <code>xi</code> values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/reactivepath.jl#L54-L68">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.resample_kde-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#ISOKANN.resample_kde-Tuple{Any, Any, Any}"><code>ISOKANN.resample_kde</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">resample_kde(xs, ys, n; kwargs...)</code></pre><p>Return <code>n</code> indices of <code>ys</code> such that the corresponding points &quot;fill the gaps&quot; in the KDE of <code>xs</code>. For possible <code>kwargs</code> see <code>kde_needles</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/subsample.jl#L89-L94">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.resample_kde-Tuple{SimulationData, Any, Any}"><a class="docstring-binding" href="#ISOKANN.resample_kde-Tuple{SimulationData, Any, Any}"><code>ISOKANN.resample_kde</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">resample_kde(data::SimulationData, model, n; bandwith, unique)</code></pre><p>add new samples to data by running new simulations starting at some <code>ys</code> (i.e. the propagated points) of <code>data</code> where these points are iteratively selected to be closest to the minimum of a KDE of the current chi values from <code>xs</code>. If <code>unique</code> is true, start simulations from point only where there were no simulations before. <code>bandwith</code> controls the bandwidth of the KDE.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/simulation.jl#L192-L200">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.restricted_localpdistinds-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#ISOKANN.restricted_localpdistinds-Tuple{Any, Any, Any}"><code>ISOKANN.restricted_localpdistinds</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>restricted_localpdistinds(coords, radius, atoms)</p><p>Like <code>localdists</code>, but consider only the atoms with index in <code>atoms</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/pairdists.jl#L85-L89">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.run!"><a class="docstring-binding" href="#ISOKANN.run!"><code>ISOKANN.run!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">run!(iso::Iso, n=1, epochs=1)</code></pre><p>Run the training process for the Iso model.</p><p><strong>Arguments</strong></p><p>a <code>iso::Iso</code>: The Iso model to train.</p><ul><li><code>n::Int</code>: The number of (outer) Koopman iterations.</li><li><code>epochs::Int</code>: The number of (inner) epochs to train the model for each Koopman evaluation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/iso.jl#L62-L71">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.runadaptive!-Tuple{Any}"><a class="docstring-binding" href="#ISOKANN.runadaptive!-Tuple{Any}"><code>ISOKANN.runadaptive!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">runadaptive!(iso; generations=1, nx=10, iter=100, cutoff=Inf)</code></pre><p>Train iso with adaptive sampling. Sample <code>kde</code> new data points followed by <code>iter</code> isokann iterations and repeat this <code>generations</code> times. <code>cutoff</code> specifies the maximal data size, after which new data overwrites the oldest data. <code>unique</code> enforces resampling from yet unsampled <code>ys</code> only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/iso.jl#L230-L236">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.save_reactive_path"><a class="docstring-binding" href="#ISOKANN.save_reactive_path"><code>ISOKANN.save_reactive_path</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">save_reactive_path(iso::Iso,
    coords::AbstractMatrix=coords(iso.data) |&gt; cpu;
    sigma=1,
    maxjump=1,
    out=&quot;out/reactive_path.pdb&quot;,
    source=pdbfile(iso.data),
    kwargs...)</code></pre><p>Extract and save the reactive path of a given <code>iso</code>.</p><p>Computes the maximum likelihood path with parameter <code>sigma</code> along the given data points, aligns it and saves it to the <code>out</code> path.</p><p>See also <code>reactive_path</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>iso::Iso</code>: The Iso for which the reactive path is computed.</p></li><li><p><code>coords</code>: The coordinates amongst which the shortest path is calculated</p></li><li><p><code>fullcoords</code>: The full coordinates which are used to save the computed path frames (defaults to coords).</p></li><li><p><code>weights</code>: A vector of weights applied to each atom of the coordinates, determining the relative weight for the distance calculations.</p></li><li><p><code>out=&quot;out/reactive_path.pdb&quot;</code>: The output file path for saving the reactive path.</p></li><li><p><code>source</code>: The source .pdb file providing the topology</p></li><li><p><code>kwargs...</code>: additional parameters passed to <code>reactive_path</code>.</p></li></ul><p><strong>Returns</strong></p><ul><li><code>ids</code>: The IDs of the reactive path.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/reactivepath.jl#L1-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.save_trajectory-Tuple{Any, AbstractMatrix}"><a class="docstring-binding" href="#ISOKANN.save_trajectory-Tuple{Any, AbstractMatrix}"><code>ISOKANN.save_trajectory</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">save_trajectory(filename, coords::AbstractMatrix; top::String)</code></pre><p>save the trajectory given in <code>coords</code> to <code>filename</code> with the topology provided by the file <code>top</code> using mdtraj.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/molutils.jl#L99-L103">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.savecoords"><a class="docstring-binding" href="#ISOKANN.savecoords"><code>ISOKANN.savecoords</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">savecoords(path::String, iso::Iso, coords::AbstractMatrix=coords(iso.data); sorted=true, aligned=true)</code></pre><p>Save the coordinates of the specified matrix of coordinates to a file, using the molecule in <code>iso</code> as a template. If <code>sorted</code> the sort the coordinates by their increasing χ value. If <code>align</code> then align each frame to the previous one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/iso.jl#L328-L333">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.trajectorydata_bursts-Tuple{ISOKANN.IsoSimulation, Any, Any}"><a class="docstring-binding" href="#ISOKANN.trajectorydata_bursts-Tuple{ISOKANN.IsoSimulation, Any, Any}"><code>ISOKANN.trajectorydata_bursts</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">trajectorydata_bursts(sim::IsoSimulation, steps, nk; kwargs...)</code></pre><p>Simulate a single long trajectory of <code>steps</code> times the lagtime and start <code>nk</code> burst trajectories at each step for the Koopman samples.</p><p>x0–-x––x–-     / |  / |     y y  y y</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/simulation.jl#L270-L279">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.trajectorydata_linear-Tuple{ISOKANN.IsoSimulation, Any}"><a class="docstring-binding" href="#ISOKANN.trajectorydata_linear-Tuple{ISOKANN.IsoSimulation, Any}"><code>ISOKANN.trajectorydata_linear</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">trajectorydata_linear(sim::IsoSimulation, steps; reverse=false, kwargs...)</code></pre><p>Simulate a single long trajectory of <code>steps</code> times the lagtime and use this &quot;chain&quot; to generate the corresponding ISOKANN data. If <code>reverse</code> is true, also add the time-reversed transitions</p><p>x (&lt;)–&gt; x (&lt;)–&gt; x</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/simulation.jl#L256-L263">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.OpenMM.FeaturesPairs-Tuple{OpenMMSimulation}"><a class="docstring-binding" href="#ISOKANN.OpenMM.FeaturesPairs-Tuple{OpenMMSimulation}"><code>ISOKANN.OpenMM.FeaturesPairs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">FeaturesPairs(pairs::Vector{Tuple{Int,Int}})
FeaturesPairs(system; selector=&quot;all&quot;, maxdist=Inf, maxfeatures=Inf)</code></pre><p>Creates a FeaturesPairs object from either:</p><ul><li>a list of index pairs (<code>Vector{Tuple{Int,Int}}</code>) passed directly.</li><li>an <code>OpenMMSimulation</code> or PDB file path (<code>String</code>), selecting atom pairs using MDTraj selector syntax (<code>selector</code>), optionally filtered by <code>maxdist</code> (in nm) and limited to <code>maxfeatures</code> randomly sampled pairs.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/features.jl#L37-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.propagate-Tuple{OpenMMSimulation, AbstractMatrix, Any}"><a class="docstring-binding" href="#ISOKANN.propagate-Tuple{OpenMMSimulation, AbstractMatrix, Any}"><code>ISOKANN.propagate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">propagate(sim::OpenMMSimulation, x0::AbstractMatrix, nk)</code></pre><p>Propagates <code>nk</code> replicas of the OpenMMSimulation <code>sim</code> from the inintial states <code>x0</code>.</p><p><strong>Arguments</strong></p><ul><li><code>sim</code>: An OpenMMSimulation object.</li><li><code>x0</code>: Matrix containing the initial states as columns</li><li><code>nk</code>: The number of replicas to create.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/simulators/openmm.jl#L252-L262">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.savecoords-Union{Tuple{T}, Tuple{Any, OpenMMSimulation}, Tuple{Any, OpenMMSimulation, AbstractArray{T}}} where T"><a class="docstring-binding" href="#ISOKANN.savecoords-Union{Tuple{T}, Tuple{Any, OpenMMSimulation}, Tuple{Any, OpenMMSimulation, AbstractArray{T}}} where T"><code>ISOKANN.savecoords</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">savecoords(path, sim::OpenMMSimulation, coords::AbstractArray{T})</code></pre><p>Save the given <code>coordinates</code> in a .pdb file using OpenMM</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/simulators/openmm.jl#L217-L221">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.trajectory"><a class="docstring-binding" href="#ISOKANN.trajectory"><code>ISOKANN.trajectory</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">trajectory(sim::OpenMMSimulation{Nothing}, steps=steps(sim); saveevery=1, x0=coords(sim), resample_velocities=false, throw=false, showprogress=true, reclaim=true)</code></pre><p>Simulates the trajectory of an OpenMM simulation.</p><p><strong>Arguments</strong></p><ul><li><code>sim::OpenMMSimulation{Nothing}</code>: The OpenMM simulation object.</li><li><code>steps</code>: The number of steps to simulate. Defaults to the number of steps defined in the simulation object.</li><li><code>saveevery</code>: Interval at which to save the trajectory. Defaults to 1.</li><li><code>x0</code>: Initial coordinates for the simulation. Defaults to the current coordinates of the simulation object.</li><li><code>sample_velocities</code>: Whether to sample velocities at the start of the simulation.</li><li><code>resample_velocities</code>: Whether to resample velocities after each <code>saveevery</code> steps. Defaults to <code>false</code>.</li><li><code>throw</code>: Whether to throw an error if the simulation fails. If false it returns the trajectory computed so far. Defaults to <code>false</code>.</li><li><code>showprogress</code>: Whether to display a progress bar during the simulation. Defaults to <code>true</code>.</li><li><code>reclaim</code>: Whether to reclaim CUDA memory before the simulation. Defaults to <code>true</code>.</li></ul><p><strong>Returns</strong></p><ul><li>The trajectory of the simulation as a matrix of coordinates.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/simulators/openmm.jl#L315-L333">source</a></section></details></article><h2 id="Internal-API"><a class="docs-heading-anchor" href="#Internal-API">Internal API</a><a id="Internal-API-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-API" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="ISOKANN.DataTuple"><a class="docstring-binding" href="#ISOKANN.DataTuple"><code>ISOKANN.DataTuple</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>DataTuple = Tuple{Matrix{T},Array{T,3}} where {T&lt;:Number}</p><p>We represent data as a tuple of xs and ys.</p><p>xs is a matrix of size (d, n) where d is the dimension of the system and n the number of samples. ys is a tensor of size (d, k, n) where k is the number of koopman samples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/data.jl#L5-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.IsoSimulation"><a class="docstring-binding" href="#ISOKANN.IsoSimulation"><code>ISOKANN.IsoSimulation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type IsoSimulation</code></pre><p>Abstract type representing an IsoSimulation. Should implement the methods <code>coords</code>, <code>propagate</code>, <code>dim</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/simulation.jl#L5-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.LazyTrajectory-Tuple{String}"><a class="docstring-binding" href="#ISOKANN.LazyTrajectory-Tuple{String}"><code>ISOKANN.LazyTrajectory</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">LazyTrajectory(path::String)</code></pre><p>Represents the trajectory <code>path</code> as matrix whose columns are lazily loaded from disk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/molutils.jl#L180-L184">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.ReactionCoordsRMSD"><a class="docstring-binding" href="#ISOKANN.ReactionCoordsRMSD"><code>ISOKANN.ReactionCoordsRMSD</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ReactionCoordsRMSD</code></pre><p>Instances of this object allow to compute the Root Mean Square Deviation (RMSD) to a part of a reference molecule. See also <code>ca_rmsd</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/molutils.jl#L225-L230">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.Stabilize"><a class="docstring-binding" href="#ISOKANN.Stabilize"><code>ISOKANN.Stabilize</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>TransformStabilize(target, last=nothing)</p><p>Wraps another target and permutes its target to match the previous target</p><p>Currently we also have the stablilization (wrt to the model though) inside most Transforms. TODO: Decide which to keep</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/isotarget.jl#L152-L158">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.TransformGramSchmidt2"><a class="docstring-binding" href="#ISOKANN.TransformGramSchmidt2"><code>ISOKANN.TransformGramSchmidt2</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TransformGramSchmidt()</code></pre><p>Compute the target through a Gram-Schmidt orthonormalisation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/isotarget.jl#L199-L203">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.TransformISA"><a class="docstring-binding" href="#ISOKANN.TransformISA"><code>ISOKANN.TransformISA</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>TransformISA(permute)</p><p>Compute the target via the inner simplex algorithm (without feasiblization routine). <code>permute</code> specifies whether to apply the stabilizing permutation </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/isotarget.jl#L49-L53">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.TransformPseudoInv"><a class="docstring-binding" href="#ISOKANN.TransformPseudoInv"><code>ISOKANN.TransformPseudoInv</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TransformPseudoInv(normalize, direct, eigenvecs, permute)</code></pre><p>Compute the target by approximately inverting the action of K with the Moore-Penrose pseudoinverse.</p><p>If <code>direct==true</code> solve <code>chi * pinv(K(chi))</code>, otherwise <code>inv(K(chi) * pinv(chi)))</code>. <code>eigenvecs</code> specifies whether to use the eigenvectors of the schur matrix. <code>normalize</code> specifies whether to renormalize the resulting target vectors. <code>permute</code> specifies whether to permute the target for stability.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/isotarget.jl#L103-L112">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.TransformShiftscale"><a class="docstring-binding" href="#ISOKANN.TransformShiftscale"><code>ISOKANN.TransformShiftscale</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>TransformShiftscale()</p><p>Classical 1D shift-scale (ISOKANN 1) </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/isotarget.jl#L29-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN._pickclosestloop-Tuple{AbstractVector, AbstractVector}"><a class="docstring-binding" href="#ISOKANN._pickclosestloop-Tuple{AbstractVector, AbstractVector}"><code>ISOKANN._pickclosestloop</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>scales with n=length(hs) </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/subsample.jl#L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.bootstrap-Tuple{ISOKANN.IsoSimulation, Any, Any}"><a class="docstring-binding" href="#ISOKANN.bootstrap-Tuple{ISOKANN.IsoSimulation, Any, Any}"><code>ISOKANN.bootstrap</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bootstrap(sim, nx, ny)</code></pre><p>compute initial data by propagating the molecules initial state to obtain the xs and propagating them further for the ys </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/data.jl#L22-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.centercoords-Tuple{Any}"><a class="docstring-binding" href="#ISOKANN.centercoords-Tuple{Any}"><code>ISOKANN.centercoords</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>centercoords any given states by shifting their individual 3d mean to the origin</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/molutils.jl#L4-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.chi_exit_rate-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#ISOKANN.chi_exit_rate-Tuple{Any, Any, Any}"><code>ISOKANN.chi_exit_rate</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>compute the chi exit rate as per Ernst, Weber (2017), chap. 3.3 </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/iso.jl#L280">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.constrained_free_energy-Tuple{Iso, Any}"><a class="docstring-binding" href="#ISOKANN.constrained_free_energy-Tuple{Iso, Any}"><code>ISOKANN.constrained_free_energy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">constrained_free_energy(iso, xs; sim, steps)</code></pre><p>Compute the free energy using Thermodynamic Integration.  Starting from the levelset samples xs orhtogonal simulations estimate the  mean force along χ, which is integrated to yield the PMF. </p><p><strong>Arguments</strong></p><p><code>iso</code> the Iso object. <code>xs</code>  the starting points (which should be well distributed in state space). <code>sim</code> the simulation used for the orthongal sampling. <code>steps</code> the number of steps in each orthogonal simulation.</p><p><strong>Returns</strong></p><p><code>F</code> the free energy energy surface of χ in kJ/mol up to an additive constant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/freeenergy.jl#L44-L58">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.delta_G-Tuple{Any, Any}"><a class="docstring-binding" href="#ISOKANN.delta_G-Tuple{Any, Any}"><code>ISOKANN.delta_G</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">delta_G(PMF,chi_vals)</code></pre><p>Convenience function to compute free energy differences in a double well free energy surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/freeenergy.jl#L218-L221">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.densenet-Tuple{}"><a class="docstring-binding" href="#ISOKANN.densenet-Tuple{}"><code>ISOKANN.densenet</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">densenet(; layers::Vector{Int}, activation=Flux.sigmoid, lastactivation=identity, layernorm=true) -&gt; Flux.Chain</code></pre><p>Construct a fully connected neural network (<code>Flux.Chain</code>) with customizable layer sizes, activations,  and optional input layer normalization.</p><p><strong>Arguments</strong></p><ul><li><code>layers::Vector{Int}</code>: List of layer dimensions. For example, <code>[10, 32, 16, 1]</code> creates a network with input size 10, two hidden layers of size 32 and 16, and an output layer of size 1.</li><li><code>activation</code>: Activation function applied to all layers except the last. Defaults to <code>Flux.sigmoid</code>.</li><li><code>lastactivation</code>: Activation function for the final layer. Defaults to <code>identity</code>.</li><li><code>layernorm::Bool</code>: Whether to prepend a <code>Flux.LayerNorm</code> layer to normalize the input. Defaults to <code>true</code>.</li></ul><p><strong>Returns</strong></p><p>A <code>Flux.Chain</code> composed of dense layers (and optionally a leading <code>LayerNorm</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/models.jl#L71-L86">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.energyminimization_chilevel-Tuple{Any, Any}"><a class="docstring-binding" href="#ISOKANN.energyminimization_chilevel-Tuple{Any, Any}"><code>ISOKANN.energyminimization_chilevel</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">energyminimization_chilevel(iso, x0; f_reltol=1e-3, alphaguess=1e-5, iterations=20, show_trace=false, skipwater=false, algorithm=Optim.GradientDescent, xtol=nothing)</code></pre><p>Local energy minimization on the current levelset of the chi function</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/minimumpath.jl#L146-L151">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.expectation-Tuple{Any, Any}"><a class="docstring-binding" href="#ISOKANN.expectation-Tuple{Any, Any}"><code>ISOKANN.expectation</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>expectation(f, xs)</p><p>Computes the expectation value of <code>f</code> over <code>xs</code>. Supports WeightedSamples through extra dispatch</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/isotarget.jl#L14-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.exportdata"><a class="docstring-binding" href="#ISOKANN.exportdata"><code>ISOKANN.exportdata</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">exportdata(data::AbstractArray, model, sys, path=&quot;out/data.pdb&quot;)</code></pre><p>Export data to a PDB file.</p><p>This function takes an AbstractArray <code>data</code>, sorts it according to the <code>model</code> evaluation, removes duplicates, transforms it to standard form and saves it as a PDB file  to <code>path</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/data.jl#L125-L133">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.fixperm-Tuple{Any, Any}"><a class="docstring-binding" href="#ISOKANN.fixperm-Tuple{Any, Any}"><code>ISOKANN.fixperm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fixperm(new, old)</code></pre><p>Permutes the rows of <code>new</code> such as to minimize L1 distance to <code>old</code>.</p><p><strong>Arguments</strong></p><ul><li><code>new</code>: The data to match to the reference data.</li><li><code>old</code>: The reference data.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/isotarget.jl#L79-L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.flatpairdists"><a class="docstring-binding" href="#ISOKANN.flatpairdists"><code>ISOKANN.flatpairdists</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">flatpairdists(x)</code></pre><p>Assumes each col of x to be a flattened representation of multiple 3d coords. Returns the flattened pairwise distances as columns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/pairdists.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.flattenfirst-Tuple{Any}"><a class="docstring-binding" href="#ISOKANN.flattenfirst-Tuple{Any}"><code>ISOKANN.flattenfirst</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>collapse the first and second dimension of the array <code>A</code> into the first dimension </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/data.jl#L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.flattenlast-Tuple{Any}"><a class="docstring-binding" href="#ISOKANN.flattenlast-Tuple{Any}"><code>ISOKANN.flattenlast</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flattenlast(x)</code></pre><p>Concatenate all but the first dimension of <code>x</code>. Usefull to convert a tensor of samples into a matrix </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/simulation.jl#L135-L138">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.growmodel-Tuple{Any, Any}"><a class="docstring-binding" href="#ISOKANN.growmodel-Tuple{Any, Any}"><code>ISOKANN.growmodel</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Given a model and return a copy with its last layer replaced with given output dimension <code>n</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/models.jl#L96">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.inputdim-Tuple{Flux.Chain}"><a class="docstring-binding" href="#ISOKANN.inputdim-Tuple{Flux.Chain}"><code>ISOKANN.inputdim</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>obtain the input dimension of a Flux model </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/models.jl#L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.integrate_chi-Tuple{Any, Any}"><a class="docstring-binding" href="#ISOKANN.integrate_chi-Tuple{Any, Any}"><code>ISOKANN.integrate_chi</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>integrate<em>chi(f, chi</em>vals)</p><p>Cumulative integral of the mean force with respect to χ using the trapezoid rule.</p><p><strong>Arguments</strong></p><p><code>f</code> The mean force. <code>chi_vals</code> The levelset χ values.</p><p><strong>Returns</strong></p><p><code>F</code> the (rigid) free energy surface of χ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/freeenergy.jl#L196-L206">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.load-Tuple{String}"><a class="docstring-binding" href="#ISOKANN.load-Tuple{String}"><code>ISOKANN.load</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">load(path::String, iso::Iso)</code></pre><p>Load the Iso object from a JLD2 file Note that it will be loaded to the CPU, even if it was saved on the GPU. An OpenMMSimulation will be reconstructed anew from the saved pdb file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/iso.jl#L363-L369">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.local_mean_force-Tuple{Iso, Any, Any}"><a class="docstring-binding" href="#ISOKANN.local_mean_force-Tuple{Iso, Any, Any}"><code>ISOKANN.local_mean_force</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>local<em>mean</em>force(iso, xs; sim, steps)</p><p>Compute the free energy using Thermodynamic Integration.  Bins the samples into levelsets, computes the mean force along χ locally in every levelset. (Extremely extensive sampling necessary.)</p><p><strong>Arguments</strong></p><p><code>iso</code> the Iso object. <code>xs</code>  the starting points (which should be well distributed in state space). <code>nbins</code> The number of bins/levelsets.</p><p><strong>Returns</strong></p><p><code>F</code> the free energy surface of χ in kJ/mol up to an additive constant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/freeenergy.jl#L126-L139">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.marginal_free_energy-Tuple{Iso}"><a class="docstring-binding" href="#ISOKANN.marginal_free_energy-Tuple{Iso}"><code>ISOKANN.marginal_free_energy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs"> marginal_free_energy(iso::Iso;nbins)</code></pre><p>Compute the free energy from the density of chi values.</p><p><strong>Arguments</strong></p><p><code>iso</code> the Iso object. <code>nbins</code> the number of bins of the histogram used for estimation.</p><p><strong>Returns</strong></p><p><code>F</code> the free energy energy surface of χ in kJ/mol up to an additive constant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/freeenergy.jl#L1-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.model_with_opt"><a class="docstring-binding" href="#ISOKANN.model_with_opt"><code>ISOKANN.model_with_opt</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>convenience wrapper returning the provided model with the default AdamW optimiser </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/models.jl#L39">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.outputdim-Tuple{Flux.Chain}"><a class="docstring-binding" href="#ISOKANN.outputdim-Tuple{Flux.Chain}"><code>ISOKANN.outputdim</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Obtain the output dimension of a Flux model </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/models.jl#L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.pairdistfeatures-Tuple{AbstractVector}"><a class="docstring-binding" href="#ISOKANN.pairdistfeatures-Tuple{AbstractVector}"><code>ISOKANN.pairdistfeatures</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">pairdistfeatures(inds::AbstractVector)</code></pre><p>Returns a featurizer function which computes the pairwise distances between the particles specified by <code>inds</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/pairdists.jl#L53-L57">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.pickclosest_sort-Tuple{AbstractVector, AbstractVector}"><a class="docstring-binding" href="#ISOKANN.pickclosest_sort-Tuple{AbstractVector, AbstractVector}"><code>ISOKANN.pickclosest_sort</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>pickclosest(haystack, needles)</p><p>Return the indices into haystack which lie closest to <code>needles</code> without duplicates by removing haystack candidates after a match. Note that this is not invariant under pertubations of needles</p><p>scales with n log(n) m where n=length(haystack), m=length(needles) </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/subsample.jl#L18-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.picking_aligned-Tuple{AbstractMatrix, Integer}"><a class="docstring-binding" href="#ISOKANN.picking_aligned-Tuple{AbstractMatrix, Integer}"><code>ISOKANN.picking_aligned</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">picking_aligned(x::AbstractMatrix, m::Integer)</code></pre><p>The picking algorithm using pairwise aligned distances, e.g. for molecular coordinates. Assumes the columnes of <code>x</code> to be vectors of size 3xN holding the cartesian coordinates.</p><p>see also <code>picking()</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/picking.jl#L37-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.plotatoms!"><a class="docstring-binding" href="#ISOKANN.plotatoms!"><code>ISOKANN.plotatoms!</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>scatter plot of all first &quot;O&quot; atoms of the starting points <code>xs</code> as well as the &quot;O&quot; atoms from the koopman samples to the first point from <code>ys</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/plots.jl#L1-L4">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.plotlossdata"><a class="docstring-binding" href="#ISOKANN.plotlossdata"><code>ISOKANN.plotlossdata</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>combined plot of loss graph and current atoms </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/plots.jl#L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.reactionforce"><a class="docstring-binding" href="#ISOKANN.reactionforce"><code>ISOKANN.reactionforce</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">reactionforce(iso, sim, x, direction, orth=1)</code></pre><p>Compute the vector <code>f</code> with colinear component to dchi/dx such that dchi/dx * f = 1 and orth*forcefield in the orthogonal space</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/minimumpath.jl#L126-L132">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.realsubspace-Tuple{Any}"><a class="docstring-binding" href="#ISOKANN.realsubspace-Tuple{Any}"><code>ISOKANN.realsubspace</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>computation of the real invariant subspace from complex eigenvectors </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/isotarget.jl#L492">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.resample_kde_ash"><a class="docstring-binding" href="#ISOKANN.resample_kde_ash"><code>ISOKANN.resample_kde_ash</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">resample_kde_ash(xs, ys, n=10; m=20, target=Distributions.Uniform())</code></pre><p>Pick <code>n</code> indices <code>iys</code> of the samples <code>ys</code> such that <code>[xs; ys[iys]]</code> approximates the <code>target</code> distribution. Approximates the density through an AverageShiftedHistogram on the range <code>rng</code> with window width <code>m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/subsample.jl#L121-L126">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.resample_strat-Tuple{SimulationData, Any, Any}"><a class="docstring-binding" href="#ISOKANN.resample_strat-Tuple{SimulationData, Any, Any}"><code>ISOKANN.resample_strat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">resample_strat(d::SimulationData, model, n)</code></pre><p>χ-stratified subsampling. Select n samples amongst the provided ys/koopman points of <code>d</code> such that their χ-value according to <code>model</code> is approximately uniformly distributed and propagate them. Returns a new <code>SimulationData</code> which has the new data appended.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/simulation.jl#L171-L175">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.sample_coords-Tuple{Iso, Any}"><a class="docstring-binding" href="#ISOKANN.sample_coords-Tuple{Iso, Any}"><code>ISOKANN.sample_coords</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function sample_coords(iso,n_points;xs)</code></pre><p>Convenience function to uniformly sample npoints out of the χ distribution of xs coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/freeenergy.jl#L230-L233">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.save-Tuple{String, Iso}"><a class="docstring-binding" href="#ISOKANN.save-Tuple{String, Iso}"><code>ISOKANN.save</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">save(path::String, iso::Iso)</code></pre><p>Save the complete Iso object to a JLD2 file </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/iso.jl#L354-L357">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.saveextrema-Tuple{String, Iso}"><a class="docstring-binding" href="#ISOKANN.saveextrema-Tuple{String, Iso}"><code>ISOKANN.saveextrema</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">saveextrema(path::String, iso::Iso)</code></pre><p>Save the two extermal configurations (metastabilities) to the file <code>path</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/iso.jl#L344-L348">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.scatter_chifix-Tuple{Any, Any}"><a class="docstring-binding" href="#ISOKANN.scatter_chifix-Tuple{Any, Any}"><code>ISOKANN.scatter_chifix</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>fixed point plot, i.e. x vs model(x) </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/plots.jl#L120">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.selectrows-Tuple{Any, Any}"><a class="docstring-binding" href="#ISOKANN.selectrows-Tuple{Any, Any}"><code>ISOKANN.selectrows</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>given an array of arbitrary shape, select the rows <code>inds</code> in the first dimension </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/models.jl#L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.simulationtime-Tuple{SimulationData}"><a class="docstring-binding" href="#ISOKANN.simulationtime-Tuple{SimulationData}"><code>ISOKANN.simulationtime</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simulationtime(iso::Iso)</code></pre><p>print and return the total simulation time contained in the data of <code>iso</code> in nanoseconds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/iso.jl#L314-L318">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.sqpairdist-Tuple{AbstractArray{&lt;:Any, 3}}"><a class="docstring-binding" href="#ISOKANN.sqpairdist-Tuple{AbstractArray{&lt;:Any, 3}}"><code>ISOKANN.sqpairdist</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sqpairdist(x::AbstractArray)</code></pre><p>Compute the squared pairwise distances between the columns of <code>x</code>. If <code>x</code> has 3 dimensions, the computation is batched along the 3rd dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/pairdists.jl#L25-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.subsample-Tuple{Any, AbstractMatrix, Any}"><a class="docstring-binding" href="#ISOKANN.subsample-Tuple{Any, AbstractMatrix, Any}"><code>ISOKANN.subsample</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">subsample(model, data::Array, n) :: Matrix
subsample(model, data::Tuple, n) :: Tuple</code></pre><p>Subsample <code>n</code> points of <code>data</code> uniformly in <code>model</code>. If <code>model</code> returns multiple values per sample, subsample along each dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/data.jl#L44-L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.subsample-Tuple{Any, Any}"><a class="docstring-binding" href="#ISOKANN.subsample-Tuple{Any, Any}"><code>ISOKANN.subsample</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">subsample(data, nx)</code></pre><p>return a random subsample of <code>nx</code> points from <code>data</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/data.jl#L108-L111">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.subsample_inds-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#ISOKANN.subsample_inds-Tuple{Any, Any, Any}"><code>ISOKANN.subsample_inds</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">subsample_inds(model, xs, n) :: Vector{Int}</code></pre><p>Returns <code>n</code> indices of <code>xs</code> such that <code>model(xs[inds])</code> is approximately uniformly distributed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/data.jl#L33-L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.subsample_uniformgrid-Tuple{Any, Any}"><a class="docstring-binding" href="#ISOKANN.subsample_uniformgrid-Tuple{Any, Any}"><code>ISOKANN.subsample_uniformgrid</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>subsbample_uniformgrid(ys, n) -&gt; is</p><p>given a list of values <code>ys</code>, return <code>n</code><code>indices</code>is<code>such that</code>ys[is]` are approximately uniform by picking the closest points to a randomly perturbed grid in [0,1].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/subsample.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.trajectory-Tuple{ISOKANN.AbstractLangevin}"><a class="docstring-binding" href="#ISOKANN.trajectory-Tuple{ISOKANN.AbstractLangevin}"><code>ISOKANN.trajectory</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>trajectory(l::AbstractLangevin; T=lagtime(l), x0=randx0(l), save_start=false, saveat=lagtime(l), dt=dt(l)) generate a trajectory of length <code>T</code>, starting at x0 with stepsize <code>dt</code>, saving the output every <code>saveat</code> time. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/simulators/langevin.jl#L32-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.updatehistory-Union{Tuple{T}, Tuple{T, Any}} where T"><a class="docstring-binding" href="#ISOKANN.updatehistory-Union{Tuple{T}, Tuple{T, Any}} where T"><code>ISOKANN.updatehistory</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">updatehistory(L, l)</code></pre><p>Insert the newest observations <code>l</code> of size <code>(n,d)</code> into columns 2:d+1 of the history matrix <code>L</code> of size <code>(n,h)</code>. Automatically grow the <code>n</code> dimension of <code>L</code> if <code>l</code> is bigger.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/isotarget.jl#L508-L513">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.writechemfile-Tuple{Any, Matrix}"><a class="docstring-binding" href="#ISOKANN.writechemfile-Tuple{Any, Matrix}"><code>ISOKANN.writechemfile</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">writechemfile(filename, data::Array{&lt;:Any,2}; source)</code></pre><p>Save the coordinates in <code>data</code> to <code>filename</code> with <code>source</code> as template using the Chemfiles library</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/molutils.jl#L156-L159">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.OpenMM.FeaturesAtoms"><a class="docstring-binding" href="#ISOKANN.OpenMM.FeaturesAtoms"><code>ISOKANN.OpenMM.FeaturesAtoms</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Pairwise distances between all provided atoms </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/features.jl#L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.OpenMM.featurepairs-Tuple{SimulationData}"><a class="docstring-binding" href="#ISOKANN.OpenMM.featurepairs-Tuple{SimulationData}"><code>ISOKANN.OpenMM.featurepairs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">featurepairs(d::ISOKANN.SimulationData)</code></pre><p>returns pairs of atom indices corresponding to the pairwise distance features </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/utils/features.jl#L66-L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.OpenMM.integrate_girsanov-Tuple{OpenMMSimulation}"><a class="docstring-binding" href="#ISOKANN.OpenMM.integrate_girsanov-Tuple{OpenMMSimulation}"><code>ISOKANN.OpenMM.integrate_girsanov</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">integrate_girsanov(sim::OpenMMSimulation; x0=coords(sim), steps=steps(sim), bias, reclaim=true)</code></pre><p>Integrate overdamped Langevin dynamics while computing Girsanov weights for a given bias.</p><p><strong>Arguments</strong></p><ul><li><code>sim::OpenMMSimulation</code> : The simulation object.</li><li><code>x0</code> : Initial coordinates (default: <code>coords(sim)</code>).</li><li><code>steps</code> : Number of integration steps (default: <code>steps(sim)</code>).</li><li><code>bias</code> : Function <code>x -&gt; u</code> that returns the perturbation for Girsanov reweighting.</li><li><code>reclaim</code> : Whether to preallocate memory for performance.</li></ul><p><strong>Returns</strong></p><ul><li><code>x</code> : Final coordinates.</li><li><code>g</code> : Cumulative Girsanov weight (logarithmic).</li><li><code>z</code> : Full trajectory of positions.</li></ul><p><strong>Notes</strong></p><p>The method assumes overdamped Langevin dynamics and accumulates the corresponding Girsanov weight <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/simulators/openmm.jl#L444-L463">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.OpenMM.integrate_langevin"><a class="docstring-binding" href="#ISOKANN.OpenMM.integrate_langevin"><code>ISOKANN.OpenMM.integrate_langevin</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">integrate_langevin(sim::OpenMMSimulation, x0=coords(sim); steps=steps(sim), bias=nothing, saveevery=nothing, reclaim=true)</code></pre><p>Perform standard Langevin dynamics integration for a given system.</p><p><strong>Arguments</strong></p><ul><li><code>sim::OpenMMSimulation</code> : The simulation object with system parameters.</li><li><code>x0</code> : Initial coordinates (default: <code>coords(sim)</code>).</li><li><code>steps</code> : Number of integration steps (default: <code>steps(sim)</code>).</li><li><code>bias</code> : Optional function <code>(F, x) -&gt; nothing</code> to perturb the force <code>F</code> in-place.</li><li><code>saveevery</code> : Interval to save coordinates (default: saves only final state).</li><li><code>reclaim</code> : Whether to preallocate/reclaim memory for performance.</li></ul><p><strong>Returns</strong></p><ul><li>Array of positions: either the final positions or a trajectory if <code>saveevery</code> is specified.</li></ul><p><strong>Notes</strong></p><p>Uses a simple Euler-Maruyama step for (underdamped) Langevin dynamics with optional bias. Currently the momenta are intialized as zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/simulators/openmm.jl#L399-L417">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.OpenMM.langevin_girsanov!"><a class="docstring-binding" href="#ISOKANN.OpenMM.langevin_girsanov!"><code>ISOKANN.OpenMM.langevin_girsanov!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">langevin_girsanov!(sim::OpenMMSimulation, steps=steps(sim); bias=sim.bias, saveevery=1, x0=coords(sim), resample_velocities=false, showprogress=true, throw=true, reclaim=true)</code></pre><p>Perform underdamped Langevin dynamics using the ABOBA integrator with Girsanov reweighting.</p><p><strong>Arguments</strong></p><ul><li><code>sim::OpenMMSimulation</code> : Simulation object containing masses, friction, forces, and temperature.</li><li><code>steps</code> : Number of integration steps (default: <code>steps(sim)</code>).</li><li><code>bias</code> : Function <code>q; t, sigma, F -&gt; B</code> returning perturbation force for reweighting.</li><li><code>saveevery</code> : Interval to save coordinates and weights (default: 1).</li><li><code>x0</code> : Initial coordinates (default: <code>coords(sim)</code>).</li><li><code>resample_velocities</code> : If <code>true</code>, resample momenta when saving (invalidates Girsanov weights).</li><li><code>showprogress</code> : Whether to show a progress bar.</li><li><code>throw</code> : Whether to throw errors on invalid states.</li><li><code>reclaim</code> : Whether to preallocate memory for performance.</li></ul><p><strong>Returns</strong></p><ul><li><code>WeightedSamples</code> containing:<ul><li><code>qs</code> : Saved coordinates at intervals of <code>saveevery</code>.</li><li><code>weights</code> : Corresponding Girsanov weights <code>exp(-g)</code>.</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>Uses the ABOBA splitting scheme for stable underdamped Langevin integration.</li><li>Computes Girsanov weights to account for the applied bias.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/simulators/openmm.jl#L501-L525">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.laggedtrajectory-Tuple{OpenMMSimulation, Any}"><a class="docstring-binding" href="#ISOKANN.laggedtrajectory-Tuple{OpenMMSimulation, Any}"><code>ISOKANN.laggedtrajectory</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">laggedtrajectory(sim::OpenMMSimulation, lags; steps=steps(sim), resample_velocities=true, kwargs...)</code></pre><p>Generate a lagged trajectory for a given OpenMMSimulation. E.g. x0–x–x–x  for <code>lags=3</code> and <code>steps=2</code></p><p><strong>Arguments</strong></p><ul><li><code>sim::OpenMMSimulation</code>: The simulation object.</li><li><code>lags</code>: The number of steps.</li><li><code>steps</code>: The lagtime, i.e. number of steps to take in the simulation.</li><li><code>resample_velocities</code>: Whether to resample velocities according to Maxwell-Boltzman for each lag.</li><li><code>kwargs...</code>: Additional keyword arguments to pass to the <code>trajectory</code> function.</li></ul><p><strong>Returns</strong></p><ul><li>A matrix of <code>lags</code> samples which each have <code>steps</code> simulation-steps inbetween them.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/simulators/openmm.jl#L295-L310">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ISOKANN.randx0-Tuple{OpenMMSimulation, Any}"><a class="docstring-binding" href="#ISOKANN.randx0-Tuple{OpenMMSimulation, Any}"><code>ISOKANN.randx0</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>generate <code>n</code> random inintial points for the simulation <code>mm</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/axsk/ISOKANN.jl/blob/84257ec2c69d2f1afbe814289175de2dd52c5a93/src/simulators/openmm.jl#L249">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="installation/">Installation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 29 January 2026 16:29">Thursday 29 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
